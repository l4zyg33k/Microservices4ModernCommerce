# 외부 아키텍처

외부 아키텍처는 마이크로 서비스 사이의 공간이며 가장 어려운 부분입니다. 이 책에서 지적했듯이, 마이크로 서비스는 내부의 복잡성에서 외부의 복잡성으로의 전환입니다.
대체로 마이크로 서비스의 외부 아키텍처는 개별 마이크로 서비스 간의 공간입니다. 개별 마이크로 서비스 팀의 책임이 아닌 것으로 생각하십시요.
외부 아키텍처에는 개별 마이크로 서비스가 배포되는 모든 인프라가 포함되며 마이크로 서비스를 찾고 연결하며 새로운 버전의 마이크로 서비스를 출시하고 마이크로 서비스 간 통신 및 보안을 제공합니다.
이것은 넒은 영역이며 복잡해 질수 있습니다.

외부 아키텍처는 최고의 프로그래머로 구성된 팀에서 가장 잘 처리 됩니다.
큰팀은 필요하지 않으며 정말 똑똑한 사람들로 구성된 작은 팀이 필요합니다.

```xml
 팀이 조직될때 체스의 그랜드 마스터를 이길만한큼 똑똑한 8살 짜리 아이들은 없다.
                                                           -Scott Alexander, 2015 
```

 당신이 세워야 할 목표는 각 마이크로 서비스 팀이 자체 마이크로 서비스에 집중할수 있도록 해주는 것입니다.


외부 아키텍처를 복잡하게 만드는 대부분은 새로운 기술 입니다.
 "마이크로 서비스(Micro Service)"라는 용어는 2013년 까지 널리 사용되진 않았습니다.
반면 내부 아키텍처를 지원하는 기술은 널리 확립되었습니다.
결국, 개별 마이크로 서비스는 단지 작은 응용프로그램입니다.


## 소프트 기반 인프라(Software-Based Infrastructure)

각 마이크로 서비스 팀은 자체 프로그래밍 언어, 런타임, 데이터 저장소 및 기타 상위 스택 요소를 선택할 수 있지만 모든 팀은 동일한 클라우드 공급자를 사용해야합니다.
  오늘날 주요 클라우드 플랫폼은 기술 및 상업 기능 측면에서 모두 "충분 함"입니다.

동일한 클라우드 공급자를 사용함에 있어 첫 번째 주요 이점은 여러 팀이 메시징, API 게이트웨이 및 서비스 검색과 같은 동일한 공유 리소스에 액세스 할 수 있다는 것입니다.
각 팀마다 독립적으로 선택할 수있는 기능이 있지만 일반적으로 팀 간 표준화를 원합니다. 
예를 들어, 메시징 시스템이 있는데 100 개의 다른 팀이 각각의 메시징 스택을 사용하고 싶지 않을 것입니다.
대신 중앙 집중식 팀은 하나의 구현을 선택하고 모든 마이크로 서비스 팀이 이 구현을 사용하게 해야 합니다. 이 수준에서 조각화하는 것은 의미가 없으므로 구현하기가 어렵습니다.
동일한 구현을 사용하는 모든 사람의 장점은 대기 시간이 거의 0이되는 경향이 있다는 것입니다.


## 컨테이너 오케스트레이션(Container Orchestration)

__tip)컨테이너 오케스트레이션 정의__  
오늘날의 개발에서, 애플리케이션은 더 이상 하나의 통일체가 아니라 특정 애플리케이션이 설계 의도대로 기능하도록 함께 작동해야 하는 수십 또는 수백 개의 느슨하게 결합되고 컨테이너화된 요소로 구성됩니다. 컨테이너 오케스트레이션은 개별 구성 요소와 애플리케이션 계층의 작업을 정리하는 과정을 의미합니다.

컨테이너는 개별 팀이 내부 아키텍처의 일부로 자체 마이크로 서비스를 구축하고 배포하는 데 사용됩니다.
컨테이너 오케스트레이션은 마이크로 서비스의 외부 아키텍처입니다.

간단히 말해서, 컨테이너 오케스트레이션은 물리적 호스트 또는 가상 호스트에서 개별 컨테이너를 실행하는 시스템입니다. 커맨드 라인에서 소수의 컨테이너를 관리하는 것은 매우 간단합니다. 서버로 SSH 연결하고, Docker를 설치하고, 컨테이너 이미지를 실행하고, 응용 프로그램의 호스트 / 포트를 노출합니다.  
단순하지만  몇 개이상의 컨테이너 이상에서는 작동하지 않습니다.
당신은 아마 수백, 수천개의 마이크로 서비스를 가지고 있을수 있습니다.
또한 각 마이크로 서비스는 다양한 버전과 여러 인스턴스를 포함할수도 있습니다. 하지만 이 마이크로 서비스들은 확장할 수 없습니다.

이 시스템은 또한 다음과 같은 일을 담당 할 수 있습니다.  
	• 새로운 버전의 코드 릴리스  
	• 준비 환경에 코드 배포  
	• 모든 통합 테스트 실행  
	• 프로덕션 환경에 코드 배포  
	• 서비스 레지스트리 - 마이크로 서비스 검색 및 라우팅  
	• 가장 좋은 인스턴스에 대한 호출자  
	• 로드 밸런싱 - 노드 내 및 여러 노드 간로드 균형 조정  
	• 네트워킹 오버레이 네트워크 및 동적 방화벽  
	• 자동 크기 조절 - 부하를 처리하는 컨테이너 추가 및 빼기  
	• 스토리지 - 컨테이너에 기존 볼륨 생성 및 연결  
	• 보안 - 식별, 인증 및 인증  

각각의 주제에 대해서는 다음절에서 더 자세히 다루겠습니다.

컨테이너 오케스트레이션은 기본적으로 마이크로 서비스와 함께 사용되는 새로운 형태의 플랫폼 서비스 (PaaS)입니다.
컨테이너 자체는 컨테이너 오케스트레이션 시스템이 관리하는 요소가 되어 매우 유연합니다.
컨테이너에 원하는 것을 넣을 수 있습니다. 전통적으로, PaaS는 엄격히 규정된 방법으로 접근하기 때문에 "독단적인 것"으로 간주됩니다.

 반면 컨테이너 오케스트레이션 시스템은 매우 덜 독단적이며 유연합니다.
유연성 이외에 인프라 활용도는 컨테이너 오케스트레이션 채택의 가장 중요한 요소입니다. 클라우드 환경에서도 VM (Virtual Machine)은 고정 된 CPU와 메모리를 가지고있는 반면, 단일 호스트에 배포 된 여러 컨테이너는 CPU와 메모리를 공유합니다.
컨테이너 오케스트레이션 시스템은 각 호스트 (실제 또는 가상)가 무리하지 않게 일하도록  보장합니다. 사용률은 90 % 또는 95 %로 유지되는 반면 VM은 일반적으로 10 %가 사용됩니다.
호스트의 사용률이 거의 100 %에 도달하면 컨테이너를 죽이고 사용률이 적은 다른 호스트에서 다시 시작할 수 있습니다.

클라우드와 마찬가지로 컨테이너 오케스트레이션은 모든 팀에서 사용해야하는 시스템입니다. 이러한 시스템은 설치, 배포 및 관리하기가 매우 어렵습니다. 설정 후 새로운 마이크로 서비스를 추가하는 데 드는 한계 비용은 기본적으로 0입니다. 각 마이크로 서비스 팀은 시스템을 쉽게 사용할 수 있습니다.

다음은 컨테이너 오케스트레이션 시스템이 수행 할 수있는 많은 역할 중 일부를 살펴 보겠습니다.

## 코드 배포(Releasing Code)
각 팀은 새로운 버전의 코드를 지속적으로 릴리스해야합니다.
각 팀은 자체 컨테이너를 구축하고 배포해야하지만 컨테이너 오케스트레이션 시스템을 사용하면됩니다. 모든 팀은 동일한 프로세스를 사용하여 코드를 배포해야하며 아티팩트(생성증거 ex-log)는 마이크로 서비스와 마찬가지로 단 한가지만 수행해야 하는 컨테이너 이어야 합니다.
예를 들어 응용 프로그램은 하나의 컨테이너에 있어야하며 데이터 저장소는 다른 컨테이너에 있어야합니다. 컨테이너 오케스트레이션 시스템은 모두 한 가지만 실행되는 컨테이너를 전제로합니다.

컨테이너 이미지를 빌드하기 위해서는  코드 /구성/런타임/시스템 라이브러리 /운영체제/시작및 중지 (메시지)이벤트를 포함 하여야 합니다. 이전에 논의 했듯이 이것은 소스 코드처럼 관리되는 Dockerfile YAML을 통해 관리되어 집니다.
Dockerfile은 주기적으로 테스트 및 업그레이드를 해야 하며 또한, 시작/중지 (메시지)이벤트도 테스트 해야 합니다.

(컨테이너)이미지를 만든 후에는 성공 / 실패 기준을 정해야 합니다.
예를 들어 배포가 성공적인지 테스트하기 위해 실행 할수 있는 자동화된 테스트는 무엇일까요?
가장 좋은 것은 API 호출 클라이언트를 통해 모든 API를 엄격히 검사 하는 것입니다.
무엇이 실패를 하게 만들까요? 또한 중요하지 않은 기능이 작동하지 않으면 전체 배포를 취소해야 할까요?

다음으로 당신의 자료를 빼오기 위한 전략을 정의해야 합니다.
당신은 이전 프로그램과 호환되는 마이크로서비스로 기존 구현을 대체 하고 있습니까?
아니면 이전 버전과 호환되지 않는 새로운 주요 버전을 출시 하고 있습니까?
배포가 한 번의 작업 (종종 "파란색 / 녹색"이라고 함)으로 진행되어야합니까? 아니면 점진적으로 단계별로 진행해야합니까? ex) 시간당 10 % (종종 "canary"라고도 함)씩 증가 
얼마나 많은 지역을 배포해야합니까? 얼마나 많은 오류 도메인이 있습니까? 얼마나 많은 데이터 센터가 있습니까? 어떤 데이터 센터입니까?

배포 후 컨테이너 오케스트레이션 시스템은로드 밸런서를 새 경로, 컷 오버 트래픽으로 업데이트 한 다음 컨테이너의 시작 / 중지 (메시지)이벤트를 실행해야합니다.
보시다시피,이 모든 것은 매우 복잡해질 수 있습니다. 적절한 컨테이너 오케스트레이션 시스템과 경험을 통해 몇 시간에 한 번씩 릴리스를 수행 할 수 있습니다  다시 말하지만, 컨테이너 오케스트레이션 시스템을 구축하는 데는 매우 전문화 된 소규모 팀이 필요합니다.
그런 다음 개별 팀에서 사용할 수 있습니다.

## 서비스 등록(Service Registry)
컨테이너 오케스트레이션 시스템이 호스트에 컨테이너를 배치하면 클라이언트는 컨테이너를 호출 할 수 있어야합니다. 그러나 몇 가지 복잡한 점이 있습니다.  

• 컨테이너는 몇 초, 몇 분 또는 몇 시간 동안 만 살 수 있다.
  그것들은 정의 상 일시적인 것이다.  
• 컨테이너는 종종 비표준 포트를 노출합니다.  
  예를 들어 포트 80을 통해 항상 HTTP를 누르는 것은 아니다.  
• 마이크로 서비스에는 많은 메이저 및 마이너 버전이 동시에 존재할 가능성이 높으므로 
  클라이언트는 요청에 버전을 명시해야합니다.  
• 수십, 수백 또는 수천 개의 다른 마이크로 서비스가 있습니다.  

이것들에는 클라이언트-측면과 서버-측면 2가지의 기본적인 접근 방식이 있습니다.

클라이언트 측 접근법은 개념적으로 간단합니다. 클라이언트 (API 게이트웨이, 다른 마이크로 서비스 또는 사용자 인터페이스 일 수 있음)는 독립형 서비스 레지스트리를 조회하여 완전한 엔드 포인트에 대한 경로를 요청합니다.
다시 말하지만, 클라이언트는 자신이 찾고있는 마이크로 서비스의 주요 버전과 서브 버전을 지정할 수 있어야합니다. 클라이언트는 해당 마이크로 서비스의 인스턴스에 대한 완전한 경로를 다시 가져오고, 그 다음에 다시 호출 할 수 있습니다.
 
이 접근법(클라이언트 측 접근법)의 주요 이점은 클라이언트와 끝점 사이에 중개자가 없다는 것입니다. 호출은 프록시를 순회(가로지르기)를 하지 않고 클라이언트에서 end-point(종점)으로 직접 이동합니다. 이방법은 클라이언트가 end-point(종점)을 조회하는 방법을 더욱더 풍부하게 해줍니다. 이 쿼리는 서비스 레지스트리의 정교함에 따라 버전 및 기타 서비스 품질 설정을 기술 한 공식 JSON 문서입니다.

이 방법의 가장 큰 단점은 클라이언트가 결합도의 한 형태인 각 마이크로 서비스의 조회 방법을 "학습"해야한다는 것입니다. 이것은 사용자가 알기쉽지 않습니다.
또한 각 마이크로 서비스의 구현은 다르기 때문에 각 마이크로 서비스는 쿼리의 필요성에 대한 자신만의 의미를 가지고 있어야 합니다. 뿐만아니라 클라이언트가 직접 통신하고 있는 end-point(종점)통신에 실패한 클라이언트가 다시 쿼리를 날려야 한다는 것입니다.

클라이언트 측 접근 방식이 도움이 될 수 있지만, 서버 측 방식은 오늘날 단순성과 광범위한 사용으로 인해 선호되는 경우가 많습니다. 이 방법은 기본적으로로드 밸런서를 사용하는 것입니다.
컨테이너 오케스트레이션은 컨테이너를 배치 할 때 부하 분산 장치에 끝점을 등록합니다. 클라이언트는 HTTP 헤더 또는 유사 항목을 지정하여 엔드 포인트에 대한 일부 요청을 작성할 수 있습니다.  
클라이언트 측로드 밸런싱과 달리 클라이언트는 엔드 포인트를 쿼리하는 방법을 알 필요가 없습니다. 로드 밸런서는 최상의 엔드 포인트를 선택합니다. 이방법은 매우 간단합니다.


## 로드밸런싱(Load Balancing)
서버 측 서비스 레지스트리를 사용하는 경우 로드밸런서가 필요합니다.
컨테이너를 배치 할 때마다로드 밸런서를 새로 만든 끝점의 IP, 포트 및 기타 메타 데이터로 업데이트해야합니다.

컨테이너 오케스트레이션 시스템에는 로컬 및 원격이라는 두 가지 수준의로드 균형 조정이 있습니다.

단일 호스트 내에서의 로컬 로드밸런싱 입니다. 호스트는 물리적 서버이거나 가상화 될 수 있습니다. 호스트는 하나 이상의 컨테이너를 실행합니다. 컨테이너 오케스트레이션 시스템은 정기적으로 통신하는 마이크로 서비스의 인스턴스를 배포 할 수 있습니다
동일한 물리적 호스트로 __그림 4-1__ 은 개요를 나타냅니다.

![](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_1.png)  


그림 4-1. 단일호스트 내에서의 로드밸런싱

특정 마이크로 서비스가 통신하고, 동일한 호스트에 해당 컨테이너를 지능적으로 배치함으로써 정보를 전달 받음으로써 대부분의 트래픽이 단일 호스트에 국한되기 때문에 대다수의 네트워크 트래픽을 최소화 할 수 있습니다. 모든 것이 localhost이기 때문에 네트워킹 또한 극적으로 단순화 될 수 있습니다. 지연 시간은 0이며 성능 향상에 도움이됩니다.


로컬 로드밸런싱 외에도 원격 로드밸런싱이 있는데 무엇일까요?
원격 로드밸렁싱은 트래픽을 라우팅 하는 데 사용되는 독립형 로드 밸런서입니다.
여러 호스트에 분산되어 있습니다.

특히 "API로드 밸런서"로 판매되는 제품을 찾아보십시오.
이들은 종종 전통적인 웹 서버에 구축되지만 내장되어 있습니다.
더 구체적으로 API에 대한 것입니다. 이들은 식별, 인증 및 권한 관련 보안 문제를 지원할 수 있습니다. 적절한 경우 전체 응답을 캐시 할 수 있습니다.
마지막으로 버전 관리 기능이 향상되었습니다.


## 네트워킹(Networking)
물리적 호스트에 배치 된 컨테이너는 네트워크에 가입해야합니다.
현대 클라우드의 장점 중 하나는 모든 것이 네트워크를 포함한 단순한 소프트웨어라는 것입니다. 네트워크 생성은 이제 다음과 같이 간단하게 호출 할 수 있습니다.
```xml
 $ docker network create pricing_microservice_network
```
이제 새로운 "pricing_microservice_network"네트워크가 생성되면,
컨테이너를 실행하고 네트워크를 컨테이너에 연결할 수 있습니다.
```xml
 $ docker run -itd corp/pricing_microservice
     --network=pricing_microservice_network
     --name Pricing Microservice
```

물론, 컨테이너 오케스트레이션은 모든 것을 규모에 맞는 값을 사용합니다. 사용하는 컨테이너 오케스트레이션에 따라 네트워킹이 상당히 발전 될 수 있습니다. 중요한 것은 각 마이크로 서비스의 각 계층에 대해 별도의 격리 된 네트워크를 정의한다는 것입니다.증명은 (그림 4-2)참고하십시요.

![](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_2.png)

그림 4-2 완전 분리 및 적절한 칸막이를 위해서는 소프트웨어 기반 오버레이 네트워크가 필요합니다.

오버레이 네트워크의 적절한 사용은 누군가가 네트워크에 침입했을 때 누군가가 할 수있는 피해를 제한하는 또 다른 형태의 칸막이입니다. 또한, 누군가 당신의 인벤토리 마이크로 서비스의 애플리케이션 네트워크에 침입하여 결제 마이크로 서비스의 데이터베이스 네트워크에 접근할수 없게 해줍니다.


네트워킹의 일환으로 컨테이너 오케스트레이션은 소프트웨어 기반 방화벽을 배포 할 수도 있습니다. 기본적으로 마이크로 서비스 간에는 절대적으로 네트워크 연결이 없어야합니다.
그러나 쇼핑 카트 마이크로 서비스가 체크 아웃하기 전에 최신 인벤토리를 가져와야하는 경우 컨테이너 오케스트레이션 시스템이 인벤토리 마이크로 서비스에 포트 443을 자동으로 노출하도록 설정하고 쇼핑 카트 마이크로 서비스 만 전송 레이어 보안을 통해 호출하도록 허용해야합니다 (TLS).
 예외는 마이크로 서비스 기준으로 작성되어야합니다. 또한,마이크로 서비스가 어떠한 소스로부터도 트래픽을 받아들이게 노출시키지 말아야 합니다.

## 자동 축소(Autoscaling)
상거래는 트래픽이 독특한데 그림 4-3은 선도적인 미국 소매업체의 11월 한당 간의 초당 페이지 뷰 수를 보여줍니다.

![](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_3.png)
그림 4-3 상거래 트래픽은 뾰족한 형태를 나타내고 있음

이것은 오직 웹트래픽일 뿐입니다. 만야 이 소매업자가 OmniChannel(유통채널)이 된다면 뾰족점은 더욱 극적일 것입니다. 
클라우드와 컨테이너가 나오기 전에 이 문제는 과도한 트래픽 처리때문에 정상 상태에서 시스템을 몇 퍼센트밖에 사용할수 없었습니다. 이러한 관행은 낭비를 넘어 더 이상 필요하지 않습니다.


클라우드와 자동 확장 기능이 도움이되지만 VM은 Spin Up(디스크가 읽기 및 쓰기 가 수행 되는 데 충분한 회전 속도 에 도달 하는것)에 몇 분이 걸립니다. 트래픽이 급격히 증가하는 것은 불과 몇 초 만에 5 천만 명에 달하는 유명인이 소셜 미디어를 통해 내 웹 사이트로 연결되는 링크를 게시 할 때 발생합니다. 이 상황에서 당신은 시간이 부족합니다.

컨테이너는 단지 몇 밀리 초 내에 제공 될 수 있기 때문에 도움이됩니다.
컨테이너가 실행되는 호스트는 이미 사전 제공 되어 있습니다. 컨테이너 오케스트레이션 시스템은 일부 컨테이너를 인스턴스화하면됩니다.

자동 확장 기능은 버전을 인식해야합니다. 예를 들어  마이크로서비스의 2.23 및 3.1 버전 가격은 자동으로 축소될 필요가 있습니다.

## 저장 (Storage)

네트워킹과 마찬가지로 스토리지도 소프트웨어로 정의됩니다.  
컨테이너 자체는 대부분 변경 불가능합니다. 로컬 컨테이너에 파일을 쓰면 안됩니다. 영구적 인 내용은 중복, 고 가용성, 백업 등의 원격 볼륨에 기록해야합니다. 이러한 원격 볼륨은 주로 클라우드 기반의 스토리지 서비스입니다.  
각 마이크로 서비스에 대한 볼륨을 정의한 다음 적합한 볼륨에 적합한 볼륨을 적절한 위치에 부착하는 것은 까다로운 문제입니다.

## 보안 (Security)
네트워크 수준의 보안이 절대적으로 필요합니다.하지만 그 위에 추가 보안 계층이 필요합니다.


세 가지 레벨 :식별, 인증 , 권한부여

식별은 모든 사용자가 자신을 식별하도록합니다.
사용자는 사람, 사용자 인터페이스, API 게이트웨이 또는 기타 마이크로 서비스 일 수 있습니다. 식별은 종종 사용자 이름 또는 공개 키를 통해 이루어집니다.
사용자가 자신을 식별 한 후에는 사용자를 인증해야합니다.

인증은 사용자가 자신이 주장하는 사람인지 확인합니다.  인증은 종종 암호 또는 개인 키를 통해 이루어집니다.

식별되고 인증 된 후에 사용자는 조치를 수행 할 수있는 권한부여가 되어야 합니다.

마이크로 서비스의 모든 발신자는 네트워크 내 에서 올바르게 식별되고, 인증되고, 인증되어야합니다. 하나의 마이크로 서비스가 손상 될 수 있는데 이때 당신은 손상된 마이크로 서비스로부터 공격이 시작되는 것을 원하지 않습니다.

 ## API 게이트웨이 (API Gateway)

 모바일 장치의 웹 페이지 또는 화면에는 수십 개의 다른 마이크로 서비스에서 데이터를 검색해야 할 수 있습니다. 각 고객은 그에 맞는 데이터가 필요합니다. 예를 들어, 웹 페이지에 20 개의 제품 속성이 표시 될 수 있지만 Apple Watch에는 하나만 표시 될 수 있습니다.

 당신은 중개자 역할을하는 일종의 API 게이트웨이가 필요할 것입니다. __[그림 4-4]__ 참고

 ![](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_4.png)  
 [그림4-4]  웹사이트 패턴