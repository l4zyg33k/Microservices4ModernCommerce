# 외부 아키텍처 (Outer Architecture)

외부 아키텍처는 마이크로 서비스 사이의 공간이며 가장 어려운 부분입니다. 이 책에서 지적했듯이, 마이크로 서비스는 내부의 복잡성에서 외부의 복잡성으로의 전환입니다. 대체로 마이크로 서비스의 외부 아키텍처는 개별 마이크로 서비스 간의 공간입니다. 이를 개별 마이크로 서비스 팀의 책임으로 생각하지 마십시오.

외부 아키텍처에는 개별 마이크로 서비스가 배포되는 모든 인프라가 포함되며 마이크로 서비스를 찾고 연결하며 새로운 버전의 마이크로 서비스를 출시하고 마이크로 서비스 간 통신 및 보안을 제공합니다. 이것은 복잡해질 수있는 넓은 영역입니다.

외부 아키텍처는 최고의 프로그래머로 구성된 단일 팀에서 가장 잘 처리됩니다. 큰 팀은 필요하지 않습니다. 정말 영리한 사람들로 구성된 소규모 팀이 필요합니다.

```xml
 팀이 조직될때 체스의 그랜드 마스터를 이길만한큼 똑똑한 8살 짜리 아이들은 없다.
                                                           -Scott Alexander, 2015 
```

당신이 세워야 할 목표는 각 마이크로 서비스 팀이 자체 마이크로 서비스에 집중할수 있도록 해주는 것입니다.

외부 아키텍처를 복잡하게 만드는 요소 중 하나는 대부분의 기술이 새로운 것이라는 점입니다. "마이크로 서비스"라는 용어는 2013 년까지 널리 사용되지 않았지만 내부 아키텍처를 지원하는 기술은 모두 널리 확립되어 있습니다. 결국, 개별 마이크로 서비스는 단지 작은 응용 프로그램인 것입니다.

## 소프트 기반 인프라 (Software-Based Infrastructure)

각 마이크로 서비스 팀은 자체 프로그래밍 언어, 런타임, 데이터 스토어 및 기타 상위 스택 요소를 선택할 수 있지만 모든 팀이 동일한 클라우드 공급자를 사용하도록 제한해야 합니다. 오늘날 주요 클라우드 플랫폼은 기술 및 상업 기능 측면에서 모두 "충분히 우수" 합니다.

동일한 클라우드 공급자를 사용하는 데 있어 첫 번째 주요 이점은 여러 팀이 메시징, API 게이트웨이 및 서비스 검색과 같은 동일한 공유 리소스에 액세스 할 수 있다는 것입니다. 각 팀마다 독립적으로 선택할 수있는 능력이 있지만 일반적으로 팀 간 표준화를 원합니다. 예를 들어, 100개의 팀이 각자의 메시징 스택을 사용하고 싶지는 않을 것입니다. 대신, 중앙 집중식 팀은 하나의 구현을 선택하고 모든 마이크로 서비스 팀이 이를 사용하도록 해야 합니다.  이 수준에서 파편화 하는 것은 의미가 없고 구현하기도 어렵습니다. 동일한 구현을 사용하는 모든 사람의 장점은 대기 시간이 거의 0이되는 경향이 있다는 것입니다.

클라우드 공급 업체를 기반으로 표준화함으로써 조직은 클라우드 공급 업체 중 하나와 경쟁력을 구축할 수 있습니다. 공용 클라우드는 표준화되지 않으며 각 클라우드를 완벽하게 사용하려면 전문 지식이 필요합니다. 개인은 자신이 배정된 팀에 관계 없이 적용 가능한 역량을 개발할 수 있습니다. 또한, 팀은 다른 사용자가 시작하는 데 사용할 수 있는 청사진과 모범 사례도 게시할 수 있습니다.

여러 개의 클라우드를 사용하여 작업하는 것은 불필요한 복잡성을 가중시키므로 피하는 것이 좋습니다.

## 컨테이너 오케스트레이션 (Container Orchestration)

```
**__tip)컨테이너 오케스트레이션 정의__**
오늘날의 개발에서, 애플리케이션은 더 이상 하나의 통일체가 아니라 특정 애플리케이션이 설계 의도대로 기능하도록 함께 작동해야 하는 수십 또는 수백 개의 느슨하게 결합되고 컨테이너화된 요소로 구성됩니다. 
컨테이너 오케스트레이션은 개별 구성 요소와 애플리케이션 계층의 작업을 정리하는 과정을 의미합니다.
```

컨테이너는 개별 팀이 내부 아키텍처의 일부로 자체 마이크로 서비스를 구축하고 배포하는 데 사용됩니다. 컨테이너 오케스트레이션은 마이크로 서비스의 외부 아키텍처입니다.

간단히 말해서, 컨테이너 오케스트레이션은 물리적 호스트 또는 가상 호스트에서 개별 컨테이너를 실행하는 시스템입니다. 커맨드 라인에서 소수의 컨테이너를 관리하는 것은 매우 간단합니다. 서버로 SSH 연결하고, Docker를 설치하고, 컨테이너 이미지를 실행하고, 응용 프로그램의 호스트 / 포트를 노출합니다.   단순하지만 몇 개이상의 컨테이너에서는 작동하지 않습니다. 당신은 아마 수백, 수천개의 마이크로 서비스를 가지고 있을수 있으며 각 마이크로 서비스는 다양한 버전과 여러 인스턴스를 포함할수도 있습니다. 하지만 이 마이크로 서비스들은 확장할 수 없습니다.

이 시스템은 또한 다음과 같은 일을 담당 할 수 있습니다.  

	• 새로운 버전의 코드 릴리스  
	• 준비 환경에 코드 배포  
	• 모든 통합 테스트 실행  
	• 프로덕션 환경에 코드 배포  
	• 서비스 레지스트리 - 마이크로 서비스 검색 및 최상의 인스턴스 라우팅
	• 로드 밸런싱 - 노드 내 및 여러 노드 간 로드 균형 조정  
	• 네트워킹 - 오버레이 네트워크 및 동적 방화벽  
	• 오토 스케일링 - 부하를 처리하는 컨테이너 추가 및 빼기  
	• 스토리지 - 컨테이너에 기존 볼륨 생성 및 연결  
	• 보안 - 식별 및 인증

각각의 주제에 대해서는 다음절에서 더 자세히 다루겠습니다.

컨테이너 오케스트레이션은 기본적으로 마이크로 서비스와 함께 사용되는 새로운 형태의 플랫폼 서비스(PaaS)입니다. 컨테이너 자체는 컨테이너 오케스트레이션 시스템이 관리하는 요소가 되어 매우 유연하며, 원하는 어떤 것이든 컨테이너에 넣을 수 있습니다. 전통적으로, PaaS는 엄격히 규정된 방법으로 작업을 수행하도록 한다는 점에서 "독단적인 것"으로 간주됩니다. 반면, 컨테이너 오케스트레이션 시스템은 훨씬 덜 독단적이며 매우 유연합니다.

유연성 이외에 인프라 활용도는 컨테이너 오케스트레이션 채택의 가장 중요한 요소입니다. 클라우드 환경에서도 VM(Virtual Machine)은 고정 된 CPU와 메모리를 가지고있는 반면, 단일 호스트에 배포 된 여러 컨테이너는 CPU와 메모리를 공유합니다. 컨테이너 오케스트레이션 시스템은 각 호스트 (물리 또는 가상)가 무리하지 않게 일하도록 보장합니다. 사용률은 90% 또는 95%로 유지되는 반면 VM은 일반적으로 10%가 사용됩니다. 호스트의 사용률이 거의 100 %에 도달하면 컨테이너를 제거하고 사용률이 적은 다른 호스트에서 재시작할 수 있습니다.

클라우드와 마찬가지로 컨테이너 오케스트레이션은 모든 팀에서 사용해야하는 시스템입니다. 이러한 시스템은 설치, 배포 및 관리하기가 매우 어렵습니다. 그러나 설정 후 새로운 마이크로 서비스를 추가하는 데 드는 한계 비용은 기본적으로 0입니다. 각 마이크로 서비스 팀은 이 시스템을 쉽게 사용할 수 있습니다.

다음은 컨테이너 오케스트레이션 시스템이 수행 할 수 있는 많은 역할 중 일부를 살펴 보겠습니다.

### 코드 배포 (Releasing Code)

각 팀은 새로운 버전의 코드를 지속적으로 배포해야합니다. 각 팀은 자체 컨테이너를 구축하고 배포해야하지만 컨테이너 오케스트레이션 시스템을 사용하면됩니다. 모든 팀은 동일한 프로세스를 사용하여 코드를 배포해야하며 아티팩트는 마이크로 서비스와 마찬가지로 단 한가지만 수행해야 하는 컨테이너여야 합니다. 예를 들어 응용 프로그램은 하나의 컨테이너에 있어야하며 데이터 저장소는 다른 컨테이너에 있어야합니다. 컨테이너 오케스트레이션 시스템은 모두 한 가지만 실행되는 컨테이너를 전제로 합니다.

컨테이너 이미지를 빌드하기 위해서는 코드 / 구성  /런타임 / 시스템 라이브러리 / 운영체제 / 시작 및 중지 (메시지) 이벤트를 포함하여야 합니다. 앞서 논의한 바와 같이, 이 작업은 소스 제어에 체크되고 소스 코드처럼 관리되는 Dockerfile YAML을 통해 수행하는 것이 가장 좋습니다. Dockerfile은 정기적으로 테스트 및 업그레이드를 해야 하며, 시작 및 중지 (메시지) 이벤트도 테스트 해야 합니다.

(컨테이너) 이미지를 만든 후에는 성공 / 실패 기준을 정해야 합니다. 예를 들어 배포가 성공적인지 테스트하기 위해 실행 할수 있는 자동화된 테스트는 무엇일까요? API 및 호출 클라이언트를 통해 모든 API를 철저히 테스트하는 것이 가장 좋습니다. 그렇다면 무엇이 실패를 하게 만들까요? 또한 중요하지 않은 기능이 작동하지 않으면 전체 배포를 취소해야 할까요?

다음으로 출시 전략(롤아웃 전략, rollout strategy)을 정의해야 합니다. 당신은 이전 프로그램과 호환되는 마이크로서비스로 기존 구현을 대체 하고 있습니까? 아니면 이전 버전과 호환되지 않는 새로운 주요 버전을 출시 하고 있습니까? 배포가 한 번의 작업 (종종 "파란색 / 녹색"이라고 함)으로 진행되어야합니까? 아니면 시간당 10%의 비율로(종종 "canary"라고도 함) 점진적으로 진행해야합니까? 얼마나 많은 지역에 배포해야합니까? 얼마나 많은 오류 도메인이 있습니까? 얼마나 많은 데이터 센터가 있습니까? 어떤 데이터 센터입니까?

그런 다음, 배포 후, 컨테이너 오케스트레이션 시스템은 로드 밸런서를 새 경로, 컷 오버 트래픽으로 업데이트하고 컨테이너의 시작 / 중지 (메시지) 이벤트를 실행해야합니다.

보시다시피, 이 모든 것은 꽤 복잡해질 수 있습니다. 적절한 컨테이너 오케스트레이션 시스템과 경험을 통해 몇 시간에 한 번씩 배포를 수행 할 수 있습니다. 다시 말하지만, 컨테이너 오케스트레이션 시스템을 구축하는 데는 전문 인력으로 구성된 소규모 팀이 필요합니다. 그런 다음 개별 팀에서 사용할 수 있습니다.

### 서비스 등록 (Service Registry)

컨테이너 오케스트레이션 시스템이 호스트에 컨테이너를 배치하면 클라이언트는 컨테이너를 호출 할 수 있어야 합니다. 그러나 몇 가지 복잡한 점이 있습니다.  

• 컨테이너는 몇 초, 몇 분 또는 몇 시간 동안 만 살 수 있습니다. 그것들은 일시적인 것입니다.
• 컨테이너는 종종 비표준 포트를 노출합니다. 예를 들어 포트 80가 항상 HTTP인 것은 아닙니다.
• 마이크로 서비스에는 많은 메이저 및 마이너 버전이 동시에 존재할 가능성이 높으므로 클라이언트는 요청에 버전을 명시해야합니다.  
• 수십, 수백 또는 수천 개의 다른 마이크로 서비스가 있습니다.  

여기에는 클라이언트 측과 서버 측, 2가지의 기본적인 접근 방식이 있습니다.

클라이언트 측 접근방식은 개념적으로 간단합니다. 클라이언트 (API 게이트웨이 또는 다른 마이크로 서비스 또는 사용자 인터페이스일 수 있음)는 독립형 서비스 레지스트리를 조회하여 완전히 검증된 엔드 포인트에 대한 경로를 요청합니다. 다시 말하지만, 클라이언트는 자신이 찾고있는 마이크로 서비스의 주요 버전과 서브 버전을 지정할 수 있어야합니다. 클라이언트는 해당 마이크로 서비스의 인스턴스에 대한 완전한 경로를 다시 가져오고, 이 경로를 통해 계속해서 호출할 수 있습니다.
 
이 접근법(클라이언트 측 접근법)의 주요 이점은 클라이언트와 엔드 포인트 사이에 중개자가 없다는 것입니다. 호출은 프록시를 통해 순회 하지 않고 클라이언트에서 엔드 포인트로 직접 이동합니다. 또한, 이 방법은 클라이언트가 엔드 포인트를 조회하는 방법을 더욱더 풍부하게 합니다. 이 쿼리는 서비스 레지스트리의 정교함에 따라 버전 및 기타 서비스 품질 설정을 기술 한 공식 JSON 문서가 될 수 있습니다.

이 방법의 가장 큰 단점은 연결 형태인 각 마이크로 서비스를 쿼리하는 방법을 클라이언트가 "학습" 해야 한다는 것입니다. 이것은 사용자가 알기 쉽지 않습니다. 또한 각 마이크로 서비스 구현은 서로 다르기 때문에 각 마이크로 서비스는 쿼리 방법에 대해 자체적 의미가 있습니다. 뿐만 아니라 직접 통신하고 있는 엔드 포인트가 실패할 경우 클라이언트가 엔드 포인트를 다시 검색해야 합니다.

클라이언트 측 접근 방식이 도움이 될 수 있지만, 서버 측 방식은 오늘날 단순성과 광범위한 사용으로 인해 선호되는 경우가 많습니다. 이 방법은 기본적으로 로드 밸런서를 사용하는 것입니다. 컨테이너 오케스트레이션은 컨테이너를 배치 할 때 부하 분산 장치에 엔드 포인트를 등록합니다. 클라이언트는 HTTP 헤더 등을 지정하여 엔드 포인트에 대한 일부 요청을 작성할 수 있습니다.  

클라이언트 측 로드 밸런싱과 달리 클라이언트는 엔드 포인트를 조회하는 방법을 알 필요가 없습니다. 로드 밸런서는 최상의 엔드 포인트를 선택하며, 이방법은 매우 간단합니다.

### 로드 밸런싱 (Load Balancing)

서버 측 서비스 레지스트리를 사용하는 경우 로드 밸런서가 필요합니다. 컨테이너를 배치 할 때마다 로드 밸런서를 새로 만든 엔드 포인트의 IP, 포트 및 기타 메타 데이터로 업데이트해야합니다.

컨테이너 오케스트레이션 시스템에는 로컬 및 원격이라는 두 가지 수준의 로드 밸런싱이 있습니다.

로컬 로드 밸런싱은 단일 호스트 내에서 로드 밸런싱을 수행합니다. 호스트는 물리적 서버이거나 가상화 될 수 있습니다. 호스트는 하나 이상의 컨테이너를 실행합니다. 컨테이너 오케스트레이션 시스템에서는 동일한 물리적 호스트에 정기적으로 통신하는 마이크로 서비스 인스턴스를 배포할 수 있습니다. **그림 4-1** 은 개요를 나타냅니다.

![그림 4-1. 단일호스트 내에서의 로드 밸런싱](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_1.png)  

_그림 4-1. 단일호스트 내에서의 로드 밸런싱_

특정 마이크로 서비스가 통신하고, 동일한 호스트에 해당 컨테이너를 지능적으로 배치하고 정보를 전달 받음으로써 대다수의 네트워크 트래픽을 최소화 할 수 있습니다. 대부분의 트래픽이 단일 호스트에 국한되기 때문입니다. 모든 것이 localhost이기 때문에 네트워킹 또한 극적으로 단순화 될 수 있습니다. 지연 시간은 0이므로 성능이 향상됩니다.

로컬 로드 밸런싱 외에도 원격 로드밸런싱이 있는데 무엇일까요? 원격 로드 밸런싱은 트래픽을 라우팅 하는데 사용되는 독립형 로드 밸런서입니다. 이는 여러 호스트에 분산되어 있습니다.

특히 "API로드 밸런서"로 판매되는 제품을 찾아보십시오. 이러한 제품은 기존의 웹 서버를 기반으로 구축되는 경우가 많지만, API 전용으로 구축되었습니다. 이들은 식별, 인증 및 권한 관련 보안 문제를 지원할 수 있으며, 적절한 경우 전체 응답을 캐시 할 수 있습니다. 마지막으로, 버전 관리 기능이 향상되었습니다.

### 네트워킹 (Networking)

물리적 호스트에 배치된 컨테이너는 네트워크에 연결해야 합니다. 현대 클라우드의 장점 중 하나는 모든 것이 네트워크를 포함한 단순한 소프트웨어라는 것입니다. 네트워크 생성은 이제 다음과 같이 간단하게 호출 할 수 있습니다.

```xml
 $ docker network create pricing_microservice_network
```

이제 새로운 "pricing_microservice_network"네트워크가 생성되면, 컨테이너를 실행하고 네트워크를 컨테이너에 연결할 수 있습니다.

```xml
 $ docker run -itd corp/pricing_microservice
     --network=pricing_microservice_network
     --name Pricing Microservice
```

물론, 컨테이너 오케스트레이션은 모든 것을 규모에 맞는 값을 사용합니다. 사용하는 컨테이너 오케스트레이션에 따라 네트워킹이 상당히 발전 될 수 있습니다. 중요한 것은 **그림 4-2**에서 볼 수 있듯이 각 마이크로 서비스의 각 계층에 대해 별도의 격리 된 네트워크를 정의한다는 것입니다.

![그림 4-2. 완전 분리 및 적절한 칸막이를 위해서는 소프트웨어 기반 오버레이 네트워크가 필요합니다.](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_2.png)

_그림 4-2. 완전 분리 및 적절한 칸막이를 위해서는 소프트웨어 기반 오버레이 네트워크가 필요합니다._

오버레이 네트워크의 적절한 사용은 버크헤딩의 또 다른 형태로, 네트워크 침입의 손상을 제한합니다. 또한, 누군가 당신의 인벤토리 마이크로 서비스의 애플리케이션 네트워크에 침입했을 때, 결제 마이크로 서비스의 데이터베이스 네트워크에 접근할수 없게 해줍니다.

네트워킹의 일환으로 컨테이너 오케스트레이션은 소프트웨어 기반 방화벽을 배포 할 수도 있습니다. 기본적으로 마이크로 서비스 간에는 절대적으로 네트워크 연결이 없어야 합니다. 그러나 쇼핑 카트 마이크로 서비스가 체크 아웃하기 전에 최신 인벤토리를 가져와야하는 경우에는 인벤토리 마이크로 서비스에서 포트 443을 자동으로 노출하도록 컨테이너 오케스트레이션 시스템을 구성해야 합니다. 쇼핑 카트 마이크로 서비스만 TLS(Transport Layer Security)를 통해 호출하도록 허용해야 합니다. 마이크로 서비스를 기준으로 예외를 두어야 하며, 모든 소스의 트래픽을 허용하기 위해 노출되도록 마이크로 서비스를 설정할 수는 없습니다.

### 자동 조정 (Autoscaling)

상거래는 트래픽이 독특한데 **그림 4-3**은 선도적인 미국 소매업체의 11월 한당 간의 초당 페이지 뷰 수를 보여줍니다.

![그림 4-3 상거래 트래픽은 뾰족한 형태를 나타내고 있음](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_3.png)

_그림 4-3 상거래 트래픽은 뾰족한 형태를 나타내고 있음_

이것은 오직 웹 트래픽일 뿐입니다. 만약 이 소매업자가 옴니채널(OmniChannel, 유통채널)을 이용하게 된다면 뾰족한 지점은 더욱 극적일 것입니다. 

클라우드와 컨테이너의 등장 이전에 이 문제는 과도한 트래픽 처리때문에 정상 상태에서 시스템을 몇 퍼센트밖에 사용할수 없었습니다. 이러한 관행은 낭비를 넘어 더 이상 필요하지 않습니다.

클라우드와 자동 확장 기능이 도움이되지만 VM은 스핀 업(Spin Up, 디스크가 읽기 및 쓰기 가 수행 되는 데 충분한 회전 속도 에 도달 하는것)에 몇 분이 걸립니다. 5천만명의 팔로워를 가진 연예인이 소셜 미디어를 통해 당신의 웹 사이트에 링크를 걸었을 때, 몇 초 만에 급증하는 트래픽이 발생합니다. 이 상황에서 당신은 시간이 부족합니다.

컨테이너는 단지 몇 밀리 초 내에 트래픽을 처리할 수 있기 때문에 도움이 됩니다. 컨테이너가 실행되는 호스트는 이미 사전 제공 되어 있습니다. 컨테이너 오케스트레이션 시스템은 일부 컨테이너만 인스턴스화하면 됩니다.

자동 확장 기능은 버전을 인식해야 합니다. 예를 들어, 마이크로서비스의 2.23 및 3.1 버전 가격은 자동으로 조정될 필요가 있습니다.

### 저장 (Storage)

네트워킹과 마찬가지로 스토리지도 소프트웨어로 정의됩니다. 

컨테이너 자체는 대부분 변경 불가능합니다. 로컬 컨테이너에 파일을 쓰면 안됩니다. 영구적인 모든 데이터는 중복되고 가용성이 높으며 백업되는 원격 볼륨에 기록해야 합니다. 이러한 원격 볼륨은 주로 클라우드 기반의 스토리지 서비스입니다.  

각 마이크로 서비스에 대한 볼륨을 정의한 다음 적합한 볼륨을 적절한 위치에 부착하는 것은 까다로운 문제입니다.

### 보안 (Security)

네트워크 수준의 보안이 절대적으로 필요합니다. 하지만 그 위에 추가 보안 계층이 필요합니다.

세 가지 레벨 :식별, 인증 , 권한부여

식별은 모든 사용자가 자신을 식별하도록합니다. 사용자는 사람, 사용자 인터페이스, API 게이트웨이 또는 기타 마이크로 서비스 일 수 있습니다. 식별은 종종 사용자 이름 또는 공개 키를 통해 이루어집니다. 사용자가 자신을 식별 한 후에는 사용자를 인증해야합니다.

인증은 사용자가 자신이 주장하는 사람인지 확인합니다. 인증은 종종 암호 또는 개인 키를 통해 이루어집니다.

식별되고 인증 된 후에 사용자는 조치를 수행 할 수있는 권한부여가 되어야 합니다.

마이크로 서비스를 호출하는 모든 사람은 네트워크 내에서도 적절하게 식별하고 인증하며 승인을 받아야 합니다. 하나의 마이크로 서비스가 손상 될 수 있는데 이때, 당신은 누군가가 손상된 마이크로 서비스에서 공격을 하는 것을 원하지 않을 것입니다.

### API 게이트웨이 (API Gateway)

 모바일 장치의 웹 페이지 또는 화면에는 수십 개의 다른 마이크로 서비스에서 데이터를 검색해야 할 수 있습니다. 각 고객은 그에 맞는 데이터가 필요합니다. 예를 들어, 웹 페이지에 20 개의 제품 속성이 표시 될 수 있지만 Apple Watch에는 하나만 표시 될 수 있습니다.

 당신은 __그림 4-4__에서와 같이, 중개자 역할을 하는 일종의 API Gateway를 원할 것입니다.

 ![](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_4.png)  
 [그림4-4]  Aggregator Pattern

 클라이언트는 API Gateway를 호출하고 API Gateway는 단일 응답을 작성하는 데 필요한 각 Micro Service에 대한 동시 요청을 작성하고, 그렇게 한 개의 맞춰진 데이터를 돌려받습니다. API Gateway는 종종 “프론트엔드용 백엔드”라고도 불립니다.  

API를 호출 할 때 원하는 것에 대해 쿼리가 필요합니다. 제품 레코드에는 100 개의 프로퍼티가있을 수 있습니다. 이러한 프로퍼티 중 일부는 웨어하우스에만 관련이 있습니다. 일부는 실제 스토어에만 관련이 있습니다. Micro Service는 옴니 채널이어야 함을 기억하십시오. Apple Watch에서 제품 설명을 표시하고 싶을 때, 클라이언트가 100 개의 모든 프로퍼티를 검색하는 것을 바라지 않을 것입니다. 또한 성능 저하의 문제로, API Gateway가 100개의 프로퍼티를 제품의 Micro Service에서 검색하는 것을 바라지 않을 것입니다. 대신, 각 layer는 리턴 할 프로퍼티를 지정하는 API 호출(클라이언트 → API Gateway, API Gateway → 각 Micro Service)을 만들어야 합니다. 이것은 상위 layer가 당신의 서비스에 대한 자세한 내용을 알아야 하기 때문에 결합을 만들 것입니다. 그러나 아마도 그만한 가치가 있을 것입니다.  

API Gateway의 문제점은 모든 (수십의)클라이언트와 모든  (수십, 수백 또는 수천의 )Micro Service와 상호 작용하는 방법을 알아야 하기 때문에 밀접하게 결합된 단일 구조(monoliths)가 된다는 것입니다. 주의하지 않는다면 Micro Service로 해결하려는 바로 그 문제가 다시 나타날 수 있습니다.

## 이벤트(Eventing)

 우리는 주로 Micro Service에 대한 API 호출에 대해 논의했습니다. 클라이언트, API Gateway, 그리고 또 다른 Micro Service는 동기식으로 Micro Service를 호출하여 제품의 현재 재고 수준 또는 고객의 주문 내역을 요청할 수 있습니다.

 그러나 동기 API 호출 뒤에는 비동기적으로 전달되는 전체 시스템 데이터가 있습니다. 주문 Micro Service에서 고객의 주문이 업데이트 될 때마다 사본이 이벤트로 나옵니다. 환불은 이벤트로 처리해야 합니다. 이벤트는 Micro Service가 메시지를 처리 할 수 있을 때까지 메시지를 버퍼링 할 수 있기 때문에 동기 API 호출보다 훨씬 유용합니다. 강한 결합을 줄임으로써 정전을 예방합니다.

 Micro Service에 속한 실제 데이터 외에도 시스템 이벤트 역시 Micro Service로 표현됩니다. 로그 메시지는 이벤트로 스트리밍 됩니다. - 컨테이너 조직 시스템은 매 컨테이너가 실행될 때마다 이벤트를 보내고, health-check가 실패할 때마다 이벤트도 꺼져야 합니다. Micro Service 환경 속 모든 것이 이벤트입니다.


__tip__
 왜 ‘메시지’가 아닌 ‘이벤트’라고 부를까요? 이벤트는 근본적으로는 메시지이지만, volume에서 주요한 차이가 있습니다. 전통적으로 메시지는 독점적으로 데이터를 전달하는 데 사용되었습니다. Micro Service 생태계에서 모든 것이 하나의 이벤트입니다. 현대의 이벤트 시스템은 초당 수천만 개의 이벤트를 처리 할 수 있습니다. 메시지는 더 적은 처리량을 위해 사용됩니다. 구현상의 특징이지만, 일반 메시지는 오래 보존되고 순서가 지정되어 있으며, 종종 중개역할을 합니다. 이벤트의 경우 종종 순서가 지정되지 않거나 중개역할을 하지 않습니다

  Service Oriented Architecture(SOA)의 핵심 과제는 메시지가 너무 "지능적"인, 중앙 집중식Enterprise Service Bus(ESB)를 통해 라우팅되는 것입니다. 

```xml
  Micro Service 커뮤니티는 다른 접근 방식: 단순한 애플리케이션간 연동과 파이프 처리를 선호합니다.
  —	Martin Fowler, 2014
```

이 모델에서 Micro Service ESB와 같은 "파이프"가 아닌, 스스로 모든 지능을 보유합니다.
Micro Service 환경 속에서는, 생산자와 소비자 사이에서 이벤트가 발생하지 않아야 합니다. 파이프처리는 단순해야 합니다.
멱등성(Idempotency) 역시 Micro Service에서 중요한 개념입니다. 이것은 이벤트가 여러 번 전송, 배포될 수 있으며, 이때 결과값이 다르지 않는 것을 말합니다.

다음은 멱등성이 아닌 예제입니다.  
```xml
<credit>
    <amount>100</amount>
    <forAccount>1234</account>
</credit>
```

다음은 멱등성의 예제입니다.
```xml
<credit>
     <amount>100</amount>
     <forAccount>1234</account>
<creditMemoID>4567</creditMemoId>*
</credit> 
```

## 요약(Summary)
Micro Services는 수십, 수백 또는 심지어 수천 개의 팀이 원활하게 팀 단위로 작업 할 수 있게 하며, 상거래 플랫폼을 구축하는 방법을 혁신적으로 변화시키고 있습니다. 새로운 기능은 몇 개월이 아니라 몇 시간 만에 선보일 수 있습니다.

다른 기술과 마찬가지로 단점도 있습니다. Micro Service는 복잡성, 특히 외부에서의 복잡성을 추가합니다. Micro Service를 둘러싼 기술은 급속히 발전하고 있으며 시간이 지남에 따라 더 쉽게 접근할 수 있을 것입니다.

전반적으로, Micro Service는 어플리케이션이 충분히 복잡하고, 당신이 속한 조직이 성숙한 상태인 상태에서 가치가 있습니다. Micro Service와 함께 새로운 세상에 도전해보세요. 


## 저자에 관하여(About the Author)
Kelly Goetsch는 commercetools의 운영, 개발 및 배포를 총괄하는 책임자입니다. Oracle에서 commercetools로 온 후 제품 관리를 위한 Micro Service 계획을 이끌었습니다. 그는 9자리 단위의 수익을 내는 핵심 오라클 Cloud 제품의 고위급 비즈니스와 함께 시장 진입 전략 책임을 맡았습니다.
 
Oracle에 입사하기 전에 그는 ATG(Oracle 인수)의 수석 설계사였으며 31 개의 대규모 ATG 의 프로젝트에 중요한 업무를 맡았습니다. ATG시절의 마지막 해, 그는 전세계 Walmart의 ATG 프로젝트를 감독하였습니다. 그는 시카고 일리노이 대학 (University of Illinois University)에서 경영학 정보 시스템 석사 학위와 학사 학위를 취득했습니다. 그는 분산 컴퓨팅의 핵심을 포함하여 세 가지 특허를 보유하고 있습니다.

Kelly는 상업, Micro Service 및 분산 컴퓨팅에 대한 전문 지식을 보유하고 있으며 이러한 주제에 대해 폭넓게 강연과 출판을 합니다. 그는 또한 상거래와 클라우드의 교차점에 관한 책인 ‘eCommerce in the Cloud: Bringing Elasticity to eCommerce(O’Reilly, 2014)’의 저자이기도합니다.


