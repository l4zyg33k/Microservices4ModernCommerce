# 마이크로서비스의 소개

## 마이크로서비스의 기원

"마이크로서비스"라는 용어가 2013년에 처음으로 유명해 졌지만, 그 개념은 수십년 동안 우리 옆에 있었습니다.

1. 각 프로그램이 한 가지 일을 잘하도록 하십시오. 새로운 작업을 얻으려면 새로운 기능을 추가하여 기존 프로그램을 복잡하게 만드는 대신 새로 빌드하십시오.
1. 모든 프로그램의 출력이 아직 알려지지 않은 프로그램의 입력이 될 것으로 기대하십시오. 불필요한 정보로 출력을 혼란스럽게하지 마십시오. 엄격한 열 갯수 또는 2진 입력 형식을 사용하지 마십시오. 대화식 입력을 고집하지 마십시오.
1. 운영체제 조차도 이상적으로 몇 주 이내에 시작 할 정도로 소프트웨어를 설계하고 빌드 하는 것을 일찍 해보기 바랍니다. 서투른 부분을 버리고 재건하는 것을 주저하지 마십시오.
> Doug McIlroy(1978년Unix 창립자이며, Unix pipe 발명가)

소프트웨어 업계는 복잡성을 줄인다는 목표로 대형 단일 응용 프로그램을 보다 작은 모듈로 분할할 수 있는 방법을 오랫동안 모색해 왔습니다. Unix파이프에서 DLL(동적 링크 라이브러리), 객체 지향 프로그래밍, SOA(서비스 지향 아키텍처)에 이르기까지 많은 시도가 있었습니다. 마이크로서비스는 컴퓨터 과학 이론, 조직 이론, 소프트웨어 개발 방법론, 인프라 등이 발전한 덕분에 응용 프로그램 구축에 대한 대안으로 떠올랐습니다.

마이크로서비스는 무엇인가?


![그림 2-1. 일반적인 마이크로 서비스 팀 구성](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-1.png)

_그림 2-1. 일반적인 마이크로 서비스 팀 구성_

## 마이크로서비스 소개
    마이크로서비스는 다양한 분야의 소규모 팀이 독립적으로 개발, 배포 및 관리하는 개별 비즈니스 기능입니다. 

###내부VS외부 복잡성
기본적으로, 마이크로서비스는 내부가 단순하며 외부가 복잡합니다. 마이크로서비스의 "내부"는 런타임, 비지니스 로직, 데이터 스토어에 대한 코딩, 회로 차단기, 애플리케이션 상태 관리 등이 포함됩니다. 개별 개발자가 책임 지는 모든 것입니다. 마이크로서비스의 "외부"는 애플리케이션 인스턴스의 구축 방식, 개별 인스턴스의 검색/라우팅 방식, 로드 밸런싱 장치, 메시징, 네트워크 형성을 비롯한 외부의 모든 것입니다. 마이크로서비스 팀 외부의 운영담당자가 담당하는 모든 것입니다. 단일 애플리케이션은 크기가 증가함에 따라 구축이 더 어렵습니다. 하지만 단일 리소스는 비교적 쉽게 구축하고 관리할 수 있습니다. 마이크로서비스의 경우 애플리케이션이 작고 범위가 제한되어 있기 때문에 각 마이크로서비스를 구축하고 관리하기가 매우 쉽습니다. 거대한 단일 애플리케이션은 수천만 라인의 코드를 가질 수 있는 반면에 마이크로서비스는 수천라인의 코드만 가지고 있습니다. 전문가들 중 일부는 마이크로서비스가 주말에 완전히 다시 쓰여질 수 있을 정도로 작아야만 한다고 말합니다. 그러나 각 마이크로서비스는 구축, 배포 및 관리하기가 더 쉽지만, 외부의 복잡성은 더 어렵습니다.

"10년 내에 생산성, 신뢰성, 편리성 등을 동시 향상을 약속하는 기술은 단 하나의 발전도 없습니다." -Fred Brooks, 1986-

마이크로프로세서는 특히 커머스의 경우 새로운 개별 기능의 출시 시간을 획기적으로 단축시키기 때문에 내부와 외부의 복잡성 사이에서 절충할 가치가 있습니다. 각 팀은 분리되어 있기 때문에 요구 사항을 1시간 이내에 구현하고 운영 환경에 구축할 수 있습니다. 이것은 각 팀의 업무 범위가 자신이 맡은 마이크로서비스로 제한되기 때문에 가능합니다. 반면에 단일 애플리케이션은 시간이 지남에 따라 규모가 커지므로 복잡해집니다. 시간이  지남에 따라 단일 애플리케이션의 복잡성으로 인해 개발 속도가 크게 느려집니다. 단일 애플리케이션의 크기가 커짐에 따라 새로운 기능을 구현하여 릴리스 하는데 필요한 시간은 매 분기 또는 6개월까지 증가합니다. 대규모 단일 애플리케이션으로 운영하는 많은 은행, 항공사, 소매상들은 때때로 일년에 한번 또는 2년마다 한번씩 배포됩니다. 시간이 지남에 따라 새로운 기능을 구현하지 못하면 매주, 매일 또는 매시간 신속하게 출시할 수 있는 조직에 비해 조직의 경쟁력이 크게 떨어집니다. Figure 2-2에 설명되어 있습니다. 

### 마이크로서비스 정의 

우리는 마이크로서비스의 high-level 특성에 대해 리뷰를 해볼것 입니다. 함께 정의 하는 특성이 어떤것이 있는지 살펴보겠습니다.

* 단일 목적(Single Purpose)
  * 한 가지 일을 하고, 잘 해야 합니다.
* 캡슐화(Encapsulation)
  * 각각의 마이크로서비스는 그들만의 자체 데이터를 소유하고 있습니다. 전체적인 상호작용은 잘 알려진 API들을 통해서 진행됩니다. (HTTP REST는 아니지만 자주 발생)
* 소유권(Ownership)
  * 2~15명으로 구성된 단일 팀(7명, 플러스 또는 마이너스 2명)의 사용자가 라이프 사이클 전체에 걸쳐 단일 마이크로 서비스를 개발, 구축 및 관리합니다.
* 자율성(Autonomy)
  * 각각의 팀은 어떠한 이유를 위해 언제든지 협업없이 그들의 마이크로서비스를 개발하고 구축하는것이 가능합니다. 각각의 팀은 또한 자체적인 구현 결정을 내리는데 있어 자유롭습니다.
* 다수의 버전(Multiple versions)
  * 각 마이크로서비스의 다양한 버전은 같은 환경에서 동시에 존재할 수 있습니다.
* 연출(Choreography)
  * 다수의 마이크로서비스에 걸친 작업은 분산된 방식으로 관리되며, 각 end-point는 해당 입출력을 충분하게 알 수 있을만큼 지능적입니다. 그것들은 Top-down 방식의 workflow가 아니고 다수의 마이크로서비스의 경계에 걸쳐 트랜젝션을 관리합니다.
* 궁극적인 일관성(Eventual consistency)
  * 일반적으로 모든 일관성을 갖게 됩니다.

> 마이크로서비스와 단일서비스를 비교하여 생각하는 것은 흥미롭습니다.
> 그러나 두가지 사이에는 각각의 단점이 있습니다.
> 마이크로서비스의 원칙이 맞다는 지지자는 거의 없습니다.
> 이 문서에 기술된 것은 교과서 적인 정의에 더 가깝습니다.
> 독자와 독자의 조직에 적합한 내용만 자유롭게 구현해야 합니다.
> 해당 문서를 독단적으로 진행하시면 안됩니다.

이제 각각 더 깊이 알아보겠습니다.

#### 단일 목적(Single purpose)
큰 규모의 단일 어플리케이션은 수천만 줄의 코드로 이루어져있고 그리고 수백개의 비즈니스 기능들로 구성되어 있습니다.  예를들어, 한개의 어플리케이션은 상품 관리, 재고, 가격, 프로모션, 쇼핑카트, 주문, 프로파일들 등등을 포함하고 있습니다. 반면에 마이크로서비스는 한가지 비즈니스 기능으로 구성되어 있습니다. '한 가지 일을 하고 그 일을 잘하자'라는 Unix의 기본 원칙으로 돌아가보면, 마이크로서비스는 이러한 원칙을 정의하고 있습니다. 한 가지 일을 잘 하면 팀이 집중 할 수 있고, 복잡성은 최소한으로 줄일 수 있습니다.

시간이 지날수록 어플리케이션이 점점 추가되고 많은 기능이 생기는 것은 자연스러운 현상입니다. 2000라인의로 시작한 마이크로서비스는 팀의 역량이 쌓이고 비즈니스가 발전함에 따라 10000개 이상의 라인으로 진화 할 수 있습니다. 코드의 사이즈는 마이크로서비스를 팀의 크기만큼 중요한 부분은 아닙니다. 왜냐하면 마이크로서비스의 많은 장점은 작은 규모의 팀이 함께 일하는 것으로 부터 오기 때문입니다.(2에서 15명 정도의 팀) 만약 15명이 넘는 사람이 마이크로서비스를 함께 다루면, 마이크로서비스에 많은것들이 생기고 결국 마이크로서비스가 아니게 될것 입니다. 팀 사이즈 외 에도, 빠르게 테스트를 해보는 것은 마이크로서비스의 이름을 확인 하는 것 입니다. 마이크로서비스라는 이름은 무엇을 하는건지 정확하게 묘사하고 있어야 합니다. 한개의 마이크로서비스는 "가격책정과 재고"가 아닌 "가격책정" 또는 "재고"로 불려져야 합니다.

#### 캡슐화(Encapsulation)
마이크로서비스는 자신들의 독점적인 데이터를 분명히 가지고 있습니다. 모든 마이크로서비스는 그들의 데이터 저장소, 캐쉬 저장소, 저장량 등등 을 가지고 있있습니다.(그림 2-3 참조) 다른 마이크로서비스나 시스템들은 API를 무시하고 마이크로서비스의 데이터 저장소, 캐쉬 계층, 파일시스템 또는 어떤것이 되었든 직접 쓰면 안됩니다. 하나의 마이크로서비스는 잘 정의된 API를 통해 전체적으로 상호작용을 해야만 합니다.

![그림 2-3. 각각의 마이크로서비스는 자신의 데이터를 소유](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-3.png)

그림 2-3. 각각의 마이크로서비스는 자신의 데이터를 소유

마이크로서비스의 목적은 coupling을 줄이는 것입니다. 만약 마이크로서비스 자신이 소유한 데이터만 사용하면, 그것은 coupling이 없는겁니다. 만약 2개 또는 다수의 마이스로서비스가 같은 데이터를 읽거나 쓰게된다면(그림 2-4 참조), 전에 없던 강한 coupling이 될 것 입니다.

![그림 2-4. 마이크로서비스끼리의 데이터 공유 금지; 어플리케이션 level의 API들을 사용하여 데이터 교환](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-4.png)

그림 2-4. 마이크로서비스끼리의 데이터 공유 금지; 어플리케이션 level의 API들을 사용하여 데이터 교환

비록 각각의 마이크로서비스가 데이터 저장소, 캐쉬 저장소, 저장량 또는 기다 저장소를 갖는 것이 바람직하지만, 각 마이크로서비스가 궂이 자신들의 단독적인 인스턴스를 제공할 필요는 없습니다. 예를 들어, 하나의 큰 데이터베이스나, 캐시 저장소, 저장량 또는 모든 마이크로서비스가 쓸 수 있는 다른시스템을 공급하는게 더 좋을 수 있습니다. 중요한 점은 각각의 마이크로서비스 데이터 사이에는 파티션이 필요하다는 것 입니다 : 각각 마이크로서비스는 자신의 데이터를 독점적으로 가지고 있어야 합니다. 예를 들어, 스키마가 100개인 큰 데이터베이스 1개를 사용하는 것 보다 1개의 스키마를 갖는 100개의 데이터베이스를 사용하는것이 더 좋습니다. 즉, 데이터가 아니라 리소스를 자유롭게 공유하는 것 입니다.

커플링의 단점은 결합입니다. 당신의 마이크로서비스의 가용성은 누군가가 관리하는 데이터베이스의 가용성에 따라 달라지게 됩니다. 공유 데이터베이스를 관리하는 팀은 예약된 유지 관리를 위해 데이터베이스를 중지시켜야 할 수도 있습니다.

#### 주인의식(Ownership)
일반적인 enterprise 레벨의 상업 어플리케이션은 수백명의 사람이 어플리케이션을 위해 일을 합니다. 예를 들어, 100명의 백단 개발자들이 큰 규모의 단일 어플리케이션을 구축하는건 흔한일 입니다. 이 모델의 문제점은 맴버들은 자신들이 소유하지 못했다고 느끼는 것 입니다. 각각의 개발자들은 전체 코드의 1%정도만 다룹니다. 이러한 현상으로 개발자들은 책임감을 느끼기 어렵습니다.

경제적인 관념에서 보면, 주인의식의 결여는 'Tragedy of the Commons'로 잘 알려져 있습니다. 자신의 이익만을 위해 행동하는 개인(e.g., 소를 방목하는 농부)은 필연적으로 공동의 자원(e.g., 공동의 땅)에 대한 생각을 덜 하게 될 겁니다. 대규모의 단일 어플리케이션에서도 동일한 문제가 발생합니다. 수백의 참여자들이 자신의 이익만을 위해 행동한다면 단일 어플리케이션이 더 복잡해지고 기술적 부채가 가중됩니다. 모든 사람들은 누가 만들었는지 모르는 복잡한 기술적 부채를 다뤄야 할 것 입니다.

주인의식은 마이크로서비스 작동에 큰 부분을 차지합니다. 2명에서 15명으로 구성된 작은 팀이 마이크로서비스의 전체 라이프사이클을 구축하고 관리합니다. 팀은 자신들의 마이크로서비스를 소유 하고있습니다. 주인의식은 완전히 다른 사고방식을 가져옵니다. 담당자들은 마이크로서비스의 성공을 위해 장기적으로 책임이 있기 때문에 잘 관리합니다. 수백의 사람들이 포함된 큰 규모의 단일 어플리케이션에서는 말이 안되는 일 입니다. 한 팀에 3명의 개발자, 1명의 운영담당자 및 1명의 비즈니스 분석가가 있다고 가정합니다. 이 경우, 지정된 개발자는 33% 코드에 기여하게 됩니다. 이 팀의 모든 사람은 상당한 기여를 하고 있으며 그 기여를 쉽게 인정받을 수 있습니다. 만약 마이크로서비스가 100% 완벽하게 동작한다고 하면, 팀은 신용을 얻을 수 있습니다. 같은 맥락에서, 마이크로서비스가 완벽하지 못할 경우 책임을 전가하기 쉽습니다.

개인적인 차원에서, 큰 팀속에 숨을 수 없기 때문에 마이크로서비스는 사람의 능력을 최고로 이끌어냅니다. 어느 팀에서라도 개인의 성과는 표준 중 곡선의 형태를 뛰게 합니다. 최고의 성과를 내는 사람들은 마이크로서비스에 큰 영향력을 미칠 수 있기 때문에 마이크로서비스를 좋아합니다. 마이크로서비스는 더 많은 책임감을 갖게 해주기 때문에 높은 성과를 내는 사람들에게 매력적입니다.

마이크로서비스를 책임지는 팀은 2명 이상 15명 이하로 구성되어져야만 합니다. 가장 좋은 인원수는 7명에서 土2명입니다. 팀 규모에 영향을 미치는 몇가지 흥미로운 연구결과가 있습니다.

* 2명
  * 활용 할 기술이 부족합니다. 2사람은 "팀"으로 부르기 힘듭니다. 이것은 스스로의 과제만 해결 할 수 있는 관계에 가깝습니다.
* 3명
  * 한 사람은 종종 제외되거나 한 사람이 두명을 통제하기 때문에 불안정한 그룹을 이룹니다.
* 4명
  * 4명으로 이루어져 응집력이 있기 보단, 2명씩 나누어 지게 됩니다.
* 5명에서 9명
  * "팀"의 기분이 나게 됩니다. 충분히 활용 할 기술력이 있고, 소규모 팀의 불안정함을 피할 수 있고, 모두가 의견을 들을 수 있을 수 있습니다.
* 10명에서 15명
  * 팀이 너무 커집니다. 모두가 의견을 들을 수 없고, 작은 그룹으로 나누어 지게 됩니다.
    
각 팀은 개발, 운영, 데이터 저장 관리, 보안, 프로젝트 매니저, 요구사항 분석 등등 다양한 기술을 가지고 있어야 합니다. 종종 팀은 한명의 비즈니스 분석가, 한명 또는 두명의 운영인력 그리고 소수의 개발자고 구성됩니다. 종종 한 팀 내의 각각 다른 구성원의 일을 수행합니다. 예를 들어, 5명으로 구성 팀에서 단일 운영인력이 휴가를 간다고 하면 한명의 개발자가 운영업무를 대체 합니다.

팀 규모에서 중요한 원동력은 신뢰 입니다. 진짜 일을 하기 위해서는 신뢰가 필요합니다. 만약 팀에서 신뢰가 부족하게 된다면, 개인들은 자신들을 보호하면서 보상받으려고 합니다. 이러한 보호는 종종 과도한 서류작업(i.e., 변경 요청, 생산 준비 상태 검토, 아키텍처 검토)과 문서 형태를 취합니다. 비록 이런것이 문제가 발생 하였을 때 책임을 분산시킬 수 있을 수 있지만, 이러한 행동은 조직의 목표에 역효과를 발생 시킵니다. 규모가 작고, 신뢰할 수 있는 팀은 이러한 문제를 겪지 않습니다.

팀 규모를 보는 또 다른 방법은 의사 소통 경로입니다. 팀 구성원이 추가됨에 따라 커뮤니케이션 경로가 기하 급수적으로 증가하고, 진행 속도가 느려집니다. Fred Brooks가 1975년 쓴 'The Mythical Man Month'라는 책에서 팀 내 의사 소통의 경로수를 계산하는 공식을 발표 하였습니다. 한 팀에서, 의사소통의 경로 수는 [n*(n–1)]/2 (n은 팀사이즈)로 정의 됩니다. 아래 그림 2-5에서 볼수 있듯이 2명으로 구성된 팀은 1개의 의사소통 경로가 존재하지만 20명이 존재하는 팀의 의사소통 경로는 190개 입니다. 경로의 수가 작을 수록 더 빠른 개발이 이루어 지고 직원들의 만족도를 높일 수 있습니다.

![그림 2-5. 팀에서의 커뮤니케이션 경로](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-5.png)

그림 2-5. 팀에서의 커뮤니케이션 경로

#### 자율성(Autonomy) 
주인의식은 자율성 없이 존재 할 수 없습니다. 자율성은 마이크로서비스 중 많은 부분을 의미합니다.

각각의 팀은 프로그래밍 언어, 런타임, 저장소 그리고 고려해야할 사항들에 대한 비즈니스적 문제를 풀기위해서 가장 적합한 기술을 선택할 수 있습니다. 제품의 이미지의 치수를 조정하는 마이크로서비스를 위한 기술 스택은 쇼핑 카트 마이크로서비스의 기술 스택과 매우 다르게 보일 것 입니다. 각 팀은 각 부분에서 필요한 가장 최적합한 기술 스택을 선택 할 수 있습니다. 그리고 그 결정에 책임을 집니다. 각각의 마이크로서비스는 API를 통해서 노출됩니다. 그래서 세부 구현 사항을 그렇게 중요한 사항은 아닙니다. 말하자면, 기업들이 각 팀에게 옵션 메뉴중 선택을 하도록 요구하는것이 타당합니다. 예를 들어, 프로그래밍 언어는 Java, Scala, Node.js 등이 있습니다. 데이터저장소 옵션은 MongoDB, Cassandra 또는 MariaDB가 될 수 있습니다. 무엇이 되었든 각 팀은 가장 일하는데 적합한 상품 타입(Relational, Document, Key/Value, etc.)을 선택 할 수 있지만, 꼭 제품(MongoDB, Cassandra, MariaDB) 그 자체는 아닙니다. 팀은 API Protocol/format, 메세징, 로깅, 알림 등과 같이 구현의 세부 정보를 표준화 해야 합니다. 하지만 내부적으로 사용하는 기술은 각 팀에 달려 있습니다.

기술의 선택과 함께, 각 팀은 그 결정들이 마이크로서비스의 밖에서 보이지 않는 한 아키텍쳐나 구현에 대한 결정을 해야합니다. 각 마이크로서비스의 아키텍쳐를 승인하는 전사적 차원의 아키텍쳐 검토위원회가 있으면 안됩니다. 코드의 리뷰는 외부의 있는 누군가가 아니라 팀에 속한 개발자가 수행해야 합니다. 좋든지 나쁘던지, 구현에 대한 결정은 마이크로서비스를 소유하고 책임감을 가지고 있는 팀에 따라야 합니다. 만약 마이크로서비스가 기대에 부흥하지 못한다면, 새로운 팀을 구성해야 합니다. 각각의 마이크로서비스는 세부적인 비스니스를 수행하고 있기 때문에 작은 규모를 가지고 있어야 한다는걸 기억하여야 합니다.

각팀은 완벽히 고립된 상태에서 다른팀에 의존하지 않고 마이크로서비스를 구축하고 운영해야합니다.
한 팀은 다른팀에 사로잡혀 라이브러리를 구축하면 안됩니다.
하나의 마이크로서비스는 시작하거나 운영을 하면서 다른 마이크로서비스를 호출 할 필요가 없어야 합니다.
각 마이크로서비스는 독립적으로 구현되고 관리되게 구축된 나눠진 어플리케이션 입니다.

각 팀은 언제든 어떤 이유든 새로운 버전의 마이크로서비스를 배포 할 수 있어야 합니다.
만약 2.4버전의 마이크로서비스를 현재 사용하고 있다면, 그 팀은 2.5버전과 3.0 버전까지 배포 할 수 있어야 합니다.

#### 다양한 버전(Multiple version)
마이크로서비스의 또 다른 정의된 특성은 동일한 환경에 둘 이상의 마이크로서비스 버전을 동시에 배포할 수 있는 능력입니다.
예를 들어, 버전 2.2, 2.3, 2.4 그리고 3.0 으로 책정된 마이크로서비스는 동시에  제품에 존재 할 수 있습니다.
모든 버전은 트래픽을 처리할 수 있습니다. 클라이언트(e.g., 판매 관점에서 웹, 모바일 그리고 키오스크) 및 다른 마이크로서비스는 HTTP 요청을 할 때 특정버전의 마이크로서비스를 요청 할 수 있습니다.
이것은 대게 URL을 통해 이루어집니다.(e.g., /inventory/2/ or /inventory?version=2)
이것은 최소 기능 제품(MVPs)에 배포 할때 유용합니다.
v1을 배포하고 사용자들에게 사용하도록 합니다. 나중에 더 완벽한 제품인 v2를 배포합니다.
단일 배포를 할 때와 다르게 "Lock"을 걸지 않아도 됩니다.

반면에 단일 어플리케이션의 경우, 융통성이 없습니다. 대게, 한가지 버전의 단일 어플리케이션만 주어진 시간에만 존재합니다.
버전 2.2의 단일 어플리케이션이 완전히 중단 된 후 버전 2.3이 전개되며 트래픽이 다시 동작합니다.

여러 클라이언트를 지원하는 것은 마이크로서비스의 강력한 능력이고, 진정으로 omnichannel 상업을 가능하게 합니다.
클라이언트와 기타 마이크로서비스는 특정한 주요 API 버전으로 코드화 할 수 있습니다.
에코시스템 코드가 주요 버전1이라고 가정합니다. 마이크로서비스를 담당하는 팀은 버전 1.1, 1.2, 1.3을 구현하고 배포된 API에 영향이 없는 선에서 버그를 수정하고 새로운 기능을 구현 할 수 있습니다.
그림 2-6에서 보는것과 같이 버전1과 API의 호환성이 끊어지고 나중에, 팀은 버전 2를 배포 할 수 있습니다.

![그림 2-6. 같은 서비스의 여러 버전을 통해 클라이언트가 독립적으로 진화](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-6.png)

그림 2-6. 같은 서비스의 여러 버전을 통해 클라이언트가 독립적으로 진화

사용 가능한 새 버전이 있지만 사용할 필요가 없을 때 고객 및 기타 마이크로서비스에 알릴 수 있습니다. 버전 1과 2는 공존하게 됩니다.
1년 후 버전2가 배포 되었을때, 누구도 버전1을 사용하지 않는다면 버전 1은 완전하게 제거 됩니다.

단일 어플리케이션은 모든 클라이언트가 동일한 버전의 어플리케이션을 강제적으로 사용하게하는 문제를 겪고 있습니다.
호환성에 지장을 주는 API변경 사항이 있을 때마다 모든 클라이언트를 업데이트 해야 합니다.
한사람만의 고객이 웹사이트를 사용한다면 이건 괜찮은 방법입니다. 모바일과 웹이 되면서 이것은 더 어려워 집니다.
하지만 오늘날 전 세계에서, 자신만의 배포주기를 가진 다수의 클라이언트가 있을 것 입니다.
수십의 클라이언트가 동시에 새로운 버전을 배포하는 것은 불가능한 일 입니다.
각 클라이언트는 자신들의 버전을 코드화 해야 하고, 각 클라이언트가 자체 릴리스 주기를 거치면서 이후 버전으로 마이크레이션을 수행 해야 합니다.
이 접근 방식은 고객에 관계없이 각 마이크로서비스를 신속하게 혁신 할 수 있습니다.
이러한 copuling의 부족이 마이크로 서비스를 더욱 빠르게 만듭니다.

마이크로서비스가 여러 버전을 동시에 지원하는데 따른 주요 과제는 환경의 모든 버전이 동일 한 백업 데이터스토어, 캐시 저장소, 스토리지 볼륨 또는 기타 스토리지 스키마에 대해 읽기/쓰기를 수행해야 한다는것 입니다.
마이크로서비스의 데이터는 코드가 변경되더라도 일관되어야 합니다.
예를 들어, 버전 1.2의 상품 마이크로서비스는 백업 데이터베이스에 새로운 제품을 wirte할 수 있습니다.
후에, 버전 2.2의 동일한 마이크로서비스는 동일한 제품을 검색 할 수 있고, 그 반대도 가능합니다.
이것을 깰 수는 없습니다. 유사하게, 수신 메세지는 모든 버전의 마이크로서비스에서 처리 될 수 있습니다.

##### 진화 가능한 APIs
> 여러 버전의 동일한 API가 아닌 하나의 진화가능한 API를 제공 하는것은 가능합니다. 
> 진화하는 하나의 API가 앞 단락에서 언급한 문제들을 해결하지만, 변경가능한 level을 줄이는 것에는 비용이 수반됩니다.
> 예를 들어, 기존 구현된 것에 의존하는 다수의 클라이언트가 있을 수 있기 때문에, 가격책정 API는 다시 쓸 수 없습니다.
> API를 긴급하게 다시 작성할 필요가 없는 경우, 여러 버전의 동일한 API를 사용하는 것 보다 단일 API를 사용하는 것이 더 좋습니다.

둘 이상의 버전에 대한 지원은 개발 및 구축에 새로운 양상을 더 합니다. 그것이 마이크로서비스가 근본적으로 내부와 외부 복잡성 사이의 절충 안으로 보여지는 이유입니다.
그러나 클라이언트와 긴밀하게 연결되지 않아 혁신을 빨리 할수 있다는 장점은 비용을 능가합니다.

#### 연출(Choregraphy)
중앙화는 전통적인 단일 어플리케이션들의 특징입니다. 그것들은 하나의 중앙화된 상업 어플리케이션 입니다. 여러 어플리케이션에 걸쳐 비즈니스 프로세스를 조정하는 일종의 하향식 "조정자" 시스템입니다. 예를 들어, 제품 리콜 워크플로우를 계기로 제품 리콜이 이슈화 됩니다. 그림 2-7은 워크플로우가 어떻게 보이는지에 대해 간단한 개요를 보여줍니다.

![그림 2-7. 전통적인 하향식 중앙화 결합 워크플로우](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-7.png)

그림 2-7. 전통적인 하향식 중앙화 결합 워크플로우

이 모델은 강한 결합을 가지고 있습니다. 워크플로우는 결과물을 다음 어플리케이션으로 넘겨기면서 많은 어플리케이션을 거쳐 API들을 호출해야 합니다. 이로 인해 어플리케이션간 강한 결합이 이루어 집니다. 웨어하우스 API를 변경하려면 이제 전체 워크 플로우를 업데이트하고 다시 테스트해야 합니다. 워크플로우를 적절하게 테스트하려면 해당 워크플로우에서 호출하는 다른 모든 어플리케이션을 사용할 수 있어야 합니다. 간단한 API변경이라도 기업의 전체 백엔드를 다시 테스트해야 할 수 있습니다. 테스트를 자주 수행 할 수 없기 때문에 분기별 릴리스 프로덕션이 발생하게 됩니다. 중앙 집중 조정이 장애의 원인일지도 모릅니다.

마이크로서비스는 연출 보다는 통합을 선호합니다. 중앙 집중화된 코디네이터가 각 어플리케이션이 무엇을 해야 할지 지시하는 대신, 각 어플리케이션은 스스로 무엇을 해야 하는지 알 수 있는 충분한 지능을 가지고 있습니다. 

> 마이크로서비스는 종종 스마트한 종단점과 멍청한 파이프를 가지고 있다고 언급됩니다. 
> 종단점은 개별 마이크로서비스와 인터페이스 하는데 사용하느 개별적인 REST API들 입니다. 
> 파이프는 단순한 HTTP입니다.
> 만약 루트가 수정 된다면, 시스템간 요청이 거의 없습니다.

> SOA는 멍청한 종단점과 똑똑한 파이프를 가지고 있다고 언급됩니다.
> 종단점은 독립적으로 호출할 수 없는 대규모 단일 어플리케이션에서 나온 방법입니다.
> 파이프는 종종 엔터프라이즈 서비스 버스 유형의 레이어를 통해 라우팅 됩니다.
> 레이어는 서로 다른 단일 애플리케이션을 결합하기 위해 종종 방대한 양의 비즈니스 로직을 적용합니다.

이러한 모델에서, 모든 것들(예를들어 상품리콜)은 이벤트와 이벤트 버스에 게재되는것 처럼 모델링 됩니다. 관심있는 마이크로서비스는 이벤트를 수신하기 위해 요청 할 수 있습니다. 하지만 각 마이크로서비스가 어떤 이벤트를 소비해야 하는지 관리하는 중앙시스템은 없습니다. 재고 마이크로서비스의 작성자는 재고에 영향을 미치기 때문에 제품 리콜여부를 알아야 한다고 판단 할 것입니다. 

제품 리콜 예시로 돌아가 보면, choreography 기반 접근법은 그림 2-8과 같습니다.

![그림 2-8. 느슨하게 결합하고 분산되있으며 상향식 choreography](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-8.png)

그림 2-8. 느슨하게 결합하고 분산되있으며 상향식 choreography

어플리케이션은 마이크로서비스의 핵심 강점 처럼 느슨하게 결합되어 있습니다. 그림 2-9는 이번트들이 개별적인 마이크로서비스 관점에서 어떻게 보이는 지를 보여줍니다.

각각의 마이크로서비스는 이벤트를 받고, 일부 작업을 수행하고, 이벤트를 원하는 다른 서비스들을 위해서 더 많은 이벤트를 만들어 냅니다. 각 마이크로서비스는 어떤 어플리케이션이 이벤트를 생성했는지 또는 어떤 어플리케이션이 이벤트를 소비하는지 모릅니다. 이것은 분산 시스템을 위해 의도된 분리된 아키텍쳐입니다.

![그림 2-9. 이벤트 기반 아키텍쳐](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-9.png)

그림 2-9. 이벤트 기반 아키텍쳐

#### 궁극적인 일관성(Eventual Consistency)
단일 어플리케이션은 어플리케이션 하나와 하나의 데이터 저장소가 있기 때문에 데이터 스토어에 기록된 모든 데이터가 전체 어플리케이션에 즉시 표시 되므로 매우 일관성을 가지고 있습니다. 

마이크로서비스는 자연스럽게 분포되어 있습니다. 하나의 큰 어플리케이션이 아니라, 그것은 수십 수백 또는 수천의 마이크로서비스가 있을 수 있고, 각각 데이터 저장소를 가지고 있습니다. 전체 시스템에 걸쳐 제품과 같은 일반적인 개체의 복사본이 수십개 있을 수 있습니다. 예를 들어 제품, 제품 카탈로그 및 검색 마이크로서비스에는 각각 특정 제품의 복사본이 있을 수 있습니다. 단일 애플리케이션에서는 각 제품의 복사본이 정확히 하나씩 있습니다. 이것은 파닉을 유발하지 않습니다. 대신, 비즈니스적으로 민첩하게 이 중복을 통해 무엇을 얻을지 고려해보십쇼. 

마이크로서비스를 채택하려면 궁극적인 일관성이 필요합니다. 모든 데이터는 완전히 최신 상태가 아니고 그럴 필요가 없습니다. 예를 들어, 세계에 모든 ATM들이 일관성을 가지고 있는 건 아닙니다. 대부분의 ATM은 중앙 은행과 연결이 끊기더라도 돈을 인출 할 수 있습니다. ATM은 돈을 벌 수 있는 비즈니스적 이유로 은행의 경우 일관성 보다는 가용성을 더 선호합니다. 이 세상의 많은 사람들은 일관성보다는 가용성을 선호합니다. 상서래 시스템의 대부분의 데이터는 신중한 선택이라기 보다 지배적인 단일 아키텍쳐와 중앙집중식 데이터베이스의 부산물 입니다. 

클라이언트가 10개의 제품과 함께 랜더링된 카테고리 페이지가 필요하다고 가정합니다. 단일 아키텍쳐에서는 그림 2-10 처럼 보일것입니다.

![그림 2-10. 획일적인 카테고리 페이지 보여주기](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-10.png)

그림 2-10. 획일적인 카테고리 페이지 보여주기

카테고리 method는 제품 function을 10번 호출합니다. 제품 function은 재고와 가격 function을 호출합니다. 모든 코드는 단일 프로세스 내에서 실행됩니다. 어플리케이션은 데이터베이스에 몇 밀리초 이내에 머무릅니다.

이제 그림 2-11을 통해 마이크로서비스 스타일의 아키텍처로 직접 매핑 할 경우 어떤 모습일지 살펴보겠습니다.

각각의 마이크로서비스를 수십 밀리초로 나누는 것은 효과가 없을 것 입니다. 전체적으로 존재 하지 않는다면, 마이크로서비스 간의 동기식 호출은 극히 예외적인 경우에만 드물게 일어나야 합니다. 

대신, 마이크로서비스의 가장 적합한 방식은 제품 카탈로그 마이크로 서비스를 만드것 입니다. 카테고리, 제품, 재고, 가격 그리고 다른 연계된 마이크로서비스는 각각 개별 데이터에 대한 기록 시스템 역할을 하지만, 서비스들은 그 데이터를 이벤트 형태로 내부에 게시합니다. 그림 2-12와 같이 제품 카탈로그 마이크로서비스는 이벤트를 이끌어내고 자신이 소유한 데이터 저장소에 업데이트 합니다.

맞습니다. 이렇게 할 경우 중복이 일어납니다. 현재 각 객체의 복사본들이 많이 있습니다. 하지만 현재 저장소 비용이 얼마나 드는지 고려해 보세요. 더 빠른 기술 혁신에 비하면 그 것은 작은 겁니다. 마이크로서비스의 궁극적인 목표는 copuling을 제거하는 것입니다. 데이터를 공유한다면 강한 copuling이 이루어지게 됩니다.

![그림 2-11. 분산된 단일 노드처럼 구현되는 경우 마이크로 서비스가 확장되지 않음](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-11.png)

그림 2-11. 분산된 단일 노드처럼 구현되는 경우 마이크로 서비스가 확장되지 않음

![그림 2-12. 마이크로서비스간 동기화 호출을 막은 이벤트 기반 아키텍쳐](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-12.png)

그림 2-12. 마이크로서비스간 동기화 호출을 막은 이벤트 기반 아키텍쳐

때때로 데이터는 강한 일관성이 필요합니다. 예를 들어 쇼핑카트 마이크로서비스는 쇼핑 카트에 있는 각 제품에 대해 사용 가능한 재고가 있는지 확인하기 위해 재고 마이크로서비스를 조회 해야 합니다. 만약 고객이 마지막에 계산을 하려고 할때 재고가 없다고 한다면 이것은 끔찍한 경험이 될 것입니다. 강력한 일관성에는 두가지 방법이 있습니다. 

* 클라이언트에서 기록하는 마이크로서비스 시스템을 직접 호출하는 것입니다. 예를 들어, 재고 마이크로서비스는 재고를 기록하는 시스템입니다. 비록 상품 카탈로그는 캐쉬된 재고를 보여 줄 수 있지만, 쇼핑 카트를 위한 충분히 최신화된 정보가 아닐 수 있습니다. 쇼핑카트에 화면이 표시되면, 클라이언트는 제품 카탈로그 마이크로서비스에 제품 상세 설명과 재고 마이크로서비스에 재고에 관련되어 최신 데이터인지 문의 할 수 있습니다.

* 마이크로서비가 서로 동기화하여 호출 할 수 있게 합니다. 예를 들어, /ProductCatalog?roductId=123456&forceInventorySync=true 로 제품 카탈로그 마이크로서비스가 재고 마이크로서비스에서 최신 재고를 동기적으로 조회하도록 합니다. 이러한 접근 방식은 성능과 가용성에 해를 주기 때문에 일반적으로 선호하지는 않습니다.

데이터가 완전히 일관성을 유지하는 경우는 거의 없습니다.  이 요구사항은 심사숙고 해야 합니다. 왜냐하면, 결과(coupling, 성능, 가용성)가 매우 치명적이기 때문입니다. 단일 형태로 마이크로서비스를 구현하는 함정에 빠지지 말아야 합니다.

## 마이크로서비스의 이점(Advantages of Microservices)
마이크로서비스는 많은 이점을 제공합니다. 그 중 몇개를 구체적으로 짚어보겠습니다.

### 출시기간 단축
새로운 기능들의 출시기간 단축은 마이크로서비스의 가장 중요한 이점입니다. 초기에 시장에 진입하는 전체적인 시간은 마이크로서비스로 도입된 부가적인 선행 복잡성 때문에 더 길어질 수 있습니다. 
하지만 도입되고 난 이후에는, 각 팀은 독립적으로 혁신하고 매우 빠르게 출시할 수 있습니다.(그림 2-13)

![그림 2-13. 각 팀은 독립적으로 혁신할 수 있습니다.](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-13.png)

_그림 2-13. 각 팀은 독립적으로 혁신할 수 있습니다._

시장에 빠르게 진입할 수 있는 기능을 갖는 것은 사업에서 상당히 중요한 이점을 가질 수 있습니다. 만약 출시를 위한 생산이 분기별로 이뤄지고 올바르게 바로잡기 위해 4번의 반복이 필요하다면, 결국 바로 잡는데에 1년의 시간이 소요됩니다. 만약 출시가 매일 이뤄지고 바로잡기 위해 4번의 반복이 필요하다면, 단 4일이 소요됩니다.
빠른 반복뿐 아니라, 마이크로서비스는 실패를 더 빠르게 발생시킬 수 있습니다.

마이크로서비스는 의존도를 제거하기 때문에 빠릅니다. 마이크로서비스로 다음과 같은 사항을 고려할 필요가 없습니다.

* 일원화된 구조 검토 위원회로부터의 구조적 승인
* 경영위원으로부터 출시 승인
* 수평적 의존성 - 예를들어, 공유된 DB수정을 위해 DBA를 기다릴 필요가 없고, 공급산출을 위해 영업활동이 필요가 없음
* 수직적으로 의존적인 다른팀과 출시 조정 - 예를들어, 재고 마이크로서비스는 상품 마이크로서비스 팀과 나란히 출시할 필요가 없을 것입니다.
* 이러한 기능을 수행하는 QA, 보안팀 등 각 팀의 승인

이러한 일원화된 기능을 위한 책임은 자급자족하도록 기술을 갖고 있는 각각의 작은 팀에게 전가됩니다. 각 팀은 단순히 input(보통 이벤트나 API호출) 과 output(보통 이벤트나 API들)만 상관하게 됩니다. 의존성을 제거하는 것은 개발 속도를 급격하게 증가시킵니다.

### 진정한 옴니채널 커머스
완전한 마이크로서비스 도입은 세분화된 여러 비즈니스 기능을 위해 개별 API를 갖는 것을 의미합니다. 이러한 API들 위에 있는 사용자 인터페이스는 일회용이 될 것입니다. 차후에 Apple 혹은 Facebook은 전체적인 백엔드를 구성하지 않고 쉽게 만들 수 있는 새로운 타입의 어플리케이션을 도입할 것입니다. 새로운 사용자 인터페이스가 며칠내에 구축될 수 있습니다.

### 더 낫고 덜 복잡한 코드
마이크로서비스는 하나의 마이크로서비스가 한 비즈니스 기능을 수행하기 때문에 훨씬 나은 코드를 만드려고 노력합니다. 큰 단일 어플리케이션은 수천만 라인의 코드로 이뤄지는 반면 한 마이크로서비스는 수천의 라인으로 이뤄질 수 있습니다. 물론, 적은 코드는 훨씬 규모가 큰 코드보다 더 나을 것입니다.

코드도 소규모의 팀이 소유하면서 책임지는 구조이기 때문에 더 낫습니다. 코드베이스는 작은팀의 모습입니다. 다른 모든사람들처럼 개발자들 또한 동료와 상급자에게 잘보이고 싶어합니다.

마지막으로, 각 마이크로서비스팀은 질 좋은 코드를 작성하는데에 강한 의욕이 있습니다. 전형적인 단일 어플리케이션을 운영하면서 시스템이 작동하지 않아 한밤 중에 연락을 받지 않을 수 있도록 소스를 작성합니다. 그것이 운영의 역할입니다. 하지만 마이크로서비스를 이용하면, 각각의 소규모 팀은 효율성에도 책임을 갖고 있습니다. 주로 가장 바쁜 시간대에 수정해야 했던 조잡한 코드를 확인하기 쉽습니다. 옆자리에 앉아있고 점심을 같이 먹는 동료가 매일매일 확인해주는 것은 어렵습니다.

### 책임
각 소규모 팀은 단일 마이크로서비스를 도입할 때부터 서비스를 종료할 때까지 갖고있습니다. 각 팀은 아키텍쳐를 만들고 구현, 기술적 결정에 완전한 자유를 갖습니다. 모든 자유는 각 팀, 그팀의 각 구성원들이 책임이 있다는 것을 의미합니다. 만약 어떤 팀이 새로운 오픈 소스 프로젝트를 선택했지만 6개월 만에 끝나고 교체되어야 한다면, 그 팀은 그것을 수정할 책임이 있습니다. 반대로, 팀의 마이크로서비스가 100%의 시간 동안 이용가능하고 0%의 오류 비율을 갖고있다면, 그 팀은 좋은 선택을 한 것에 대해 단독으로 인정받을 수 있습니다.

세계와의 마이크로서비스 인터페이스는 API이기 때문에, 시간경과에 따른 유용성, 오류 비율, 성능을 정량적으로 측정하는 것은 상당히 쉽습니다.
또한, 한 팀의 주요업무, 기능 등의 측면에서 처리량을 측정하기에도 쉽습니다.
하나의 작은 어플리케이션을 만들어 하나의 비즈니스 문제를 해결하고 보통 한개의 API를 공개합니다.

마이크로서비스는 직원의 질을 높이면서 뜻하지 않은 부작용을 갖고 있습니다. 규모가 큰 팀에서, 가장 못하는 직원은 쉽게 숨을 수 있습니다. 아마 그들은 문서작업을 하거나, 변경요청을 승인하거나, 다른 관리적인 업무를 수행할 것입니다. 몇몇은 그들의 코드를 다시 수정하는 작업을 할 것입니다. 하지만 작은 팀에서, 일을 잘 못하는 직원은 숨을 수 없습니다. 만약 한팀에 세명의 개발자가 있고 한명이 그의 제 역할을 하지 못한다면, 나머지 두 개발자와 나머지 직원들에게 분명하게 보일 것입니다. 기량이 저조한 직원의 경우 자발적으로 혹은 비자발적으로 떠나게됩니다. 기량이 뛰어난 직원의 경우 자유와 책임의 문화가 매력적일 것입니다.

### 강화된 분야 전문지식
마이크로서비스는 비즈니스 기능들을 세밀한 서비스로 분리되는 것을 요구합니다. 커머스시스템에서 마이크로서비스는 프로모션, 가격책정, 상품 카탈로그, 재고관리, 장바구니, 주문을 비롯한 다른 요소들을 가질 것입니다.
각 작은 팀은 하나의 단일 마이크로 서비스를 도입 부터 서비스 종료시 까지 소유합니다.

각 팀은 종종 한명 혹은 두명의 비즈니스 분석가, 상품 관리자, 혹은 기능을 살펴보는 책임을 가지면서 덜 기술적인 역할을 가진 사람을 포함합니다. 그런 사람들은 하나의 작은 기능을 살펴보기 때문에 분야에 구체적인 전문지식을 매우 깊게 발전시킬 수 있습니다. 예를들어, 비즈니스 전문가는 프로모션에 관해 그 회사의 전문가가 될 책임이 있습니다. 단일 어플리케이션으로 비즈니스 분석가는 큰 부분을 맡으려는 경향이 있고, 주기적으로 다른 기능에 할당되고 있습니다. 마이크로서비스로 한 분야에 매우 깊은 비즈니스 전문지식을 발전시키기 쉽습니다.

기술진들도 비즈니스를 지원하는데 필요한 기술적 전문지식과 알고리즘을 매우 깊게 개발할 수 있습니다. 예를들어, 재고관리 마이크로서비스를 구축하는 팀은 분산된 광범위한 전문지식을 개발할 수 있습니다.

### 쉬워진 아웃소싱
모든것들이 밀접하게 연결되어 있기 때문에, 전통적인 단일 어플리케이션을 위한 개발, 운영 및 QA와 같은 역할은 아웃소싱하기 어렵습니다.
예를들어, 새로운 지불모듈을 구축하기 위해 타사 시스템을 도입하는 것은 단 며칠이 소요될 것이지만, 개발환경을 수립하고 공유된 DB에 변경하는 프로세스를 배우고 코드를 배포하는 등 수주가 소요될 것입니다.

마이크로서비스는 아웃소싱하기 매우 쉽게 만들어줍니다. 지불모듈 도입 대신, 시스템 통합자는 하나의 단일 API를 보여주는 지불 마이크로서비스를 만드므로써 해결할 수 있습니다. 그 시스템 통합자는  지불 마이크로서비스를 구축하고 서비스로 관리하거나 다른 마이크로서비스들과 같이 관리할 수 있는 사람에게 넘길 수 있습니다. 이러한 방식으로 아웃소싱하면 서로 다른 팀 간의 커뮤니케이션 없이 수십 혹은 수백개의 마이크로서비스들을 병렬적으로 개발할 수 있습니다.

시스템 통합자를 고용하기보다 API는 타사소프트웨어 벤더들을 통해 구매될 수 있습니다. 예를들어, 서비스로 지불API를 제공하는 벤더들이 있습니다. 혹은 상품 추천이 하나의 서비스로 제공될 수 있습니다. 이 벤더들은 단순히 한 서비스로 사용될 수 있는 서비스로서 매우 차별화된 기능을 구축할 수 있습니다.

### 보안
대규모 단일 어플리케이션에서 보안은 사후에 고려되는 경우가 대다수입니다. 불가피하게 어플리케이션은 개발되고 종종 UI에서만 나중에 보안에 대한 작업이 이뤄집니다. 한 어플리케이션이 손상된 경우, 전체 어플리케이션에서 어떠한 기능이든 호출할 수 있습니다. 적절한 보안이 구현된다고 하더라도 개발자들이 사용하도록 강요할 수 있는 실질적인 방법은 없습니다. 많은 개발자들이 코드가 복잡하고 지저분하기 때문에 구현하지 않습니다.

마이크로서비스는 매우 다릅니다. 각 마이크로서비스는 하나 혹은 두개의 API로 작게 쪼개진 비즈니스 기능을 보여줍니다. 정확하게 누가 혹은 어떤 것이 각 API를 호출하고 있는지 알기 쉽습니다. 어플리케이션 단에서 보안을 다루는 것보다 API 게이트웨이 혹은 API 로드밸런서를 사용하는 것이 낫습니다. 이러한 상품들은 사용자, 역할과 조직과 같은 요소들을 정의할 수 있게 합니다. 하나의 API에서 다른 API로의 호출은 API 게이트웨이나 API 로드밸런서를 통하여 이뤄집니다. 각 요청은 도착지까지 도착할 수 있는지 확인하기 위하여 룰셋으로 평가됩니다. 예를들어, 마케팅팀의 Jenn은 고객관련 마이크로서비스로 HTTP GET 요청만 가능하지만, 주문관련 마이크로서비스는 HTTP POST와 GET 요청이 가능합니다. 기본적으로 API 게이트웨이나 API 로드밸런서에 deny-all 정책을 구현하고 모든 요청을 강제로 전달할 수 있습니다.

마이크로서비스는 또한 보안관점에서 더 나은데, 각 마이크로서비스는 독립적으로 구축되며 종종 공용클라우드 내에 전용망에 구축됩니다. 만약 공격자가 하나의 마이크로서비스에 접근하려고 한다면, 다른 마이크로서비스를 쉽게 얻지 못할 것입니다. 이것이 `bulkheading(격벽, 칸막이)`이라고 불립니다. 단일 어플리케이션이 탈취된다면, 공격자는 전체적인 데이터베이트와 모든 어플리케이션 코드에 접근할 것입니다. 더 큰 손해를 입을 수 있습니다.


## 마이크로서비스의 단점(Disadvantages of Microservices)
비록 마이크로서비스가 확실히 이점들을 가지고 있지만, 이와 마찬가지로 단점 또한 가지고 있습니다. 마이크로서비스의 목표는 새로운 기능의 제공 속도를 높이는데 있습니다. 비용을 줄이는 것이 아닙니다. 새로운 기능을 신속하게 출시하는 것은 잠재적으로 더 높은 마이크로서비스 개발비용을 상쇄하고도 남을 것입니다.

### 외부 복잡성의 어려움
마이크로서비스는 종종 외부 복잡성을 위해 내부를 희생시키는것으로 여겨집니다. 단일 어플리케이션은 내부가 복잡한 반면 마이크로서비스의 내부는 간단합니다. 단일 어플리케이션의 외부는 단순한 반면에 마이크로서비스의 외부 복잡성은 까다롭습니다. 이러한 차이를 통해 마이크로서비스팀은 새로운 기능을 매우 빠르게 구축하고 구축할 수 있습니다. 하지만, 마이크로서비스간의 상호작용을 관리하는 비용을 수반합니다.

마이크로서비스의 외부 복잡성에 대한 예시는 다음과 같습니다.
* 데이터 동기화
  * 동기식 또는 비동기식 으로 마이크로서비스간 데이터 복사
* 보안
  * 누가/어떤것이 각각의 End Point를 호출할 수 있습니까? 어떤 데이터를 전달받을 수 있는가? 어떤 동작만을 허용할 것입니까?
* 확인
  * 어떤 마이크로서비스가 사용가능합니까? 특정 마이크로서비스에서 사용되어야 하는 메시지는 어떤 것입니까?
* 버전 관리
  * 특정한 API나 특정 API 구현 버전을 어떻게 관리할 것입니까?
* 오래된 데이터
  * 어떤 마이크로서비스가 주어진 데이터를 기록할 진짜 시스템입니까?

디버깅도 더 어렵습니다. 13.2버전 장바구니 마이크로서비스와 19.1버전의 재고관리 마이크로서비스가 서로 이상하게 연관되어 있다면 어떻게 할까요?
언제든지 동시에 다양한 버전의 마이크로서비스들이 동일한 환경에 존재하는 것을 기억해야 합니다. 이러한 사항으로 모든 상관관계를 테스트 하는 것은 불가합니다. 그리고 마이크로서비스의 모든 상호작용에 대한 테스트를 중앙에서 관리하는 것은 마이크로서비스 사상에 반하는 것입니다.

### 조직 성숙도(Organizational Maturity)
조직은 탄탄한 구조, 문화와 기술적 역량을 가지고 있어야 합니다. 각각 하나씩 살펴보겠습니다.

우리가 이미 살펴본 것 처럼, 조직의 구조가 소프트웨어 생성을 어떻게 해야하는지 정합니다. 계층을 중심으로 하는 중앙화 된 조직은 계층 된 단일 어플리케이션 생성을 지향합니다. 단순한 변경일 지라도 계층 전체에 광범위한 조정이 필요하기 때문에 시간이 더 소요됩니다. 마이크로서비스를 만들기를 원하는 조직을 위한 더 나은 구조는 제품을 재구성 하는 것 입니다.

# 마이크로 서비스를 점진적으로 도입하는 방법

마이크로 서비스를 채택하는 데는 본질적으로 세가지 다른 접근법이 있습니다. 그것들을 하나씩 살펴보도록 합시다.

### NetNew

만약 여러분이 수백명의 개발자들과 함께 처음부터 대규모의 새로운 상거래 플랫폼을 구축하고 있다면, 마이크로 서비스를 사용하는 것이 좋습니다. 이 모델에서 각 팀은 하나의 마이크로 서비스를 담당합니다(그림 2-14). 모든 마이크로 서비스는 동일한 레벨에 있습니다.

![그림 2-14. 처음부터 시작할 때 마이크로 서비스를 어떻게 구성할 것인가?](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-14.png)

_그림 2-14. 처음부터 시작할 때 마이크로 서비스를 어떻게 구성할 것인가?_

작은 애플리케이션을 구축하는 경우 또는 복잡성으로 인해 초기의 마이크로 서비스 오버 헤드가 정당화될지 여부를 모르는 경우에는 이 방식을 사용하는 것이 바람직하지 않습니다. 마이크로 서비스는 수백 또는 수천의 개발자들과 수백만개의 코드 라인을 작성할 때 가장 적합합니다. 너무 일찍 최적화하지 마십시오.

### 단일성 확장 (Extend the Monolith)

이것이 대부분의 기업이 따라야 할 모델입니다. "NetNew" 접근 방식에서 볼 수 있듯이 맨 처음부터 시작하는 경우는 거의 없습니다. 대부분은 기존 상업 플랫폼에서부터 시작할 것입니다. 이 모델에서는 단일 프로그램이 소비할 개별 마이크로 서비스를 작성합니다(그림 2-15).

![그림 2-15. 기존의 단일 프로그램에서 시작하는 경우 마이크로 서비스를 구성하는 방법](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-15.png)

_그림 2-15. 기존의 단일 프로그램에서 시작하는 경우 마이크로 서비스를 구성하는 방법_

예를 들어, 새로운 비즈니스 요구 사항으로 인해 단일 프로그램 가격을 철저히 검토해야 한다고 가정해 보겠습니다. 이를 단일 프로그램에서 수행하는 대신 마이크로 서비스의 가격 책정을 다시 고려하는 기회로 활용하십시오. 단일 프로그램은 가격을 책정하기 위해 마이크로 서비스를 다시 호출합니다.
시간이 지남에 따라, 점점 더 많은 기능들이 단일 프로그램에서 벗어나 결국에는 사라집니다.

이 모델은 오늘날 대부분의 상거래 플랫폼의 표준 운영 절차입니다. 지불, 세금 계산, 배송 또는 평점 및 리뷰를 조직 내부에서는 거의 하지 않습니다. 모두 외부 공급 업체에 위탁되어 있습니다. 기능을 별도의 마이크로 서비스로 구분하는 것은 동일한 모델입니다. 단, 호출하려는 API 뒤의 팀이 회사의 일부라는 점만 다릅니다.

### 단일성 해체 (Decompose the Monolith)

이는 단일 애플리케이션이 어떻게 작성되었는지에 따라 가장 어렵거나(또는 잠재적으로 가장 쉬운)접근 방식입니다.  애플리케이션이 충분히 모듈화된 경우 모듈을 꺼내어 독립형 마이크로 서비스로 배포할 수 있습니다(그림 2-16).

![그림 2-16. 단일 모듈형 응용 프로그램을 마이크로 서비스로 분해하는 방법](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-16.png)

_그림 2-16. 단일 모듈형 응용 프로그램을 마이크로 서비스로 분해하는 방법_

여기서 어려운 점은 마이크로 서비스가 모두 동일한 데이터베이스에 코드로 작성된다는 것입니다. 단일 애플리케이션에 하나의 데이터베이스만 있을 수 있기 때문입니다.

다시 말하지만, 이것은 어렵지만 그만한 가치가 있는 일입니다.

## 요약
  오늘날 빠르게 돌아가는 시장속에서 속도는 돈이다. 새로운 기능이나 사용자 인터페이스를 출시하는 데 걸리는 시간은 매우 중요합니다. 마이크로서비스는 새로운 기능과 사용자 인터페이스를 신속하게 출시할 수 있는 최고의 아키텍처입니다. 이 아키텍처에는 많은 장점이 있는것과 동시에 단점 역시 존재합니다. 하지만, 큰 규모의 상업에서 이보다 더 좋은 방법을 찾기는 힘들것 입니다.

  이론을 살펴보았습니다. 이제, 마이크로서비스를 실행하는데 필요한 실제 기술에 대해 알아보겠습니다.