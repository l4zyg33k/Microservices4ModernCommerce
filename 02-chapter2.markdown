# 마이크로서비스의 소개

## 마이크로서비스의 기원

"마이크로서비스"라는 용어가 2013년에 처음으로 유명해 졌지만, 그 개념은 수십년 동안 우리 옆에 있었습니다.

1. 각각의 프로그램은 한가지 일을 잘 하도록 만들어야 합니다. 새로운 일을 처리해야 할 상황에서 오래 된 프로그램에 기능을 덧붙여 복잡하게 하기보다는 새롭게 만드는 것이 더 좋습니다.
1. 초기에 몇주 이내에 시도할 수 있도록 소프트웨어를 설계하고 디자인해야 합니다. 어색한 부분들을 버리고 재건하는 것을 주저하지 마십시오.
1. 모든 프로그램의 출력이 아직 알려지지 않은 프로그램의 입력이 될 수 있습니다. 프로그램 출력물을 외부 정보와 혼동하면 안됩니다. 이진 입력 형식이 강하지 않도록 해야합니다. 상호 작용적인 입력만을 고집하면 안됩니다.
  Doug McIlroy(1978년Unix 창립자이며, Unix pipe 발명가)

소프트웨어 업계는 복잡성을 줄인다는 목표로 대형 단일 응용 프로그램을 보다 작은 모듈로 분할할 수 있는 방법을 오랫동안 모색해 왔습니다. Unix파이프에서 DLL(동적 링크 라이브러리), 객체 지향 프로그래밍, SOA(서비스 지향 아키텍처)에 이르기까지 많은 시도가 있었습니다. 마이크로서비스는 컴퓨터 과학 이론, 조직 이론, 소프트웨어 개발 방법론, 인프라 등이 발전한 덕분에 응용 프로그램 구축에 대한 대안으로 떠올랐습니다.

마이크로서비스는 무엇인가?

### 마이크로서비스 정의 

우리는 마이크로서비스의 high-level 특성에 대해 리뷰를 해볼것 입니다. 함께 정의 하는 특성이 어떤것이 있는지 살펴보겠습니다.

* 단일 목적(Single Purpose)
  * 한 가지 일을 하고, 잘 해야 합니다.
* 캡슐화(Encapsulation)
  * 각각의 마이크로서비스는 그들만의 자체 데이터를 소유하고 있습니다. 전체적인 상호작용은 잘 알려진 API들을 통해서 진행됩니다. (HTTP REST는 아니지만 자주 발생)
* 소유권(Ownership)
  * 2~15명으로 구성된 단일 팀(7명, 플러스 또는 마이너스 2명)의 사용자가 라이프 사이클 전체에 걸쳐 단일 마이크로 서비스를 개발, 구축 및 관리합니다.
* 자율성(Autonomy)
  * 각각의 팀은 어떠한 이유를 위해 언제든지 협업없이 그들의 마이크로서비스를 개발하고 구축하는것이 가능합니다. 각각의 팀은 또한 자체적인 구현 결정을 내리는데 있어 자유롭습니다.
* 다수의 버전(Multiple versions)
  * 각 마이크로서비스의 다양한 버전은 같은 환경에서 동시에 존재할 수 있습니다.
* 연출(Choreography)
  * 다수의 마이크로서비스에 걸친 작업은 분산된 방식으로 관리되며, 각 end-point는 해당 입출력을 충분하게 알 수 있을만큼 지능적입니다. 그것들은 Top-down 방식의 workflow가 아니고 다수의 마이크로서비스의 경계에 걸쳐 트랜젝션을 관리합니다.
* 궁극적인 일관성(Eventual consistency)
  * 일반적으로 모든 일관성을 갖게 됩니다.

> 마이크로서비스와 단일서비스를 비교하여 생각하는 것은 흥미롭습니다.
> 그러나 두가지 사이에는 각각의 단점이 있습니다.
> 마이크로서비스의 원칙이 맞다는 지지자는 거의 없습니다.
> 이 문서에 기술된 것은 교과서 적인 정의에 더 가깝습니다.
> 독자와 독자의 조직에 적합한 내용만 자유롭게 구현해야 합니다.
> 해당 문서를 독단적으로 진행하시면 안됩니다.

이제 각각 더 깊이 알아보겠습니다.

#### 단일 목적(Single purpose)
큰 규모의 단일 어플리케이션은 수천만 줄의 코드로 이루어져있고 그리고 수백개의 비즈니스 기능들로 구성되어 있습니다.  예를들어, 한개의 어플리케이션은 상품 관리, 재고, 가격, 프로모션, 쇼핑카트, 주문, 프로파일들 등등을 포함하고 있습니다. 반면에 마이크로서비스는 한가지 비즈니스 기능으로 구성되어 있습니다. '한 가지 일을 하고 그 일을 잘하자'라는 Unix의 기본 원칙으로 돌아가보면, 마이크로서비스는 이러한 원칙을 정의하고 있습니다. 한 가지 일을 잘 하면 팀이 집중 할 수 있고, 복잡성은 최소한으로 줄일 수 있습니다.

시간이 지날수록 어플리케이션이 점점 추가되고 많은 기능이 생기는 것은 자연스러운 현상입니다. 2000라인의로 시작한 마이크로서비스는 팀의 역량이 쌓이고 비즈니스가 발전함에 따라 10000개 이상의 라인으로 진화 할 수 있습니다. 코드의 사이즈는 마이크로서비스를 팀의 크기만큼 중요한 부분은 아닙니다. 왜냐하면 마이크로서비스의 많은 장점은 작은 규모의 팀이 함께 일하는 것으로 부터 오기 때문입니다.(2에서 15명 정도의 팀) 만약 15명이 넘는 사람이 마이크로서비스를 함께 다루면, 마이크로서비스에 많은것들이 생기고 결국 마이크로서비스가 아니게 될것 입니다. 팀 사이즈 외 에도, 빠르게 테스트를 해보는 것은 마이크로서비스의 이름을 확인 하는 것 입니다. 마이크로서비스라는 이름은 무엇을 하는건지 정확하게 묘사하고 있어야 합니다. 한개의 마이크로서비스는 "가격책정과 재고"가 아닌 "가격책정" 또는 "재고"로 불려져야 합니다.

#### 캡슐화(Encapsulation)
마이크로서비스는 자신들의 독점적인 데이터를 분명히 가지고 있습니다. 모든 마이크로서비스는 그들의 데이터 저장소, 캐쉬 저장소, 저장량 등등 을 가지고 있있습니다.(그림 2-3 참조) 다른 마이크로서비스나 시스템들은 API를 무시하고 마이크로서비스의 데이터 저장소, 캐쉬 계층, 파일시스템 또는 어떤것이 되었든 직접 쓰면 안됩니다. 하나의 마이크로서비스는 잘 정의된 API를 통해 전체적으로 상호작용을 해야만 합니다.

![그림 2-3. 각각의 마이크로서비스는 자신의 데이터를 소유](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-3.png)

그림 2-3. 각각의 마이크로서비스는 자신의 데이터를 소유

마이크로서비스의 목적은 coupling을 줄이는 것입니다. 만약 마이크로서비스 자신이 소유한 데이터만 사용하면, 그것은 coupling이 없는겁니다. 만약 2개 또는 다수의 마이스로서비스가 같은 데이터를 읽거나 쓰게된다면(그림 2-4 참조), 전에 없던 강한 coupling이 될 것 입니다.

![그림 2-4. 마이크로서비스끼리의 데이터 공유 금지; 어플리케이션 level의 API들을 사용하여 데이터 교환](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-4.png)

그림 2-4. 마이크로서비스끼리의 데이터 공유 금지; 어플리케이션 level의 API들을 사용하여 데이터 교환

비록 각각의 마이크로서비스가 데이터 저장소, 캐쉬 저장소, 저장량 또는 기다 저장소를 갖는 것이 바람직하지만, 각 마이크로서비스가 궂이 자신들의 단독적인 인스턴스를 제공할 필요는 없습니다. 예를 들어, 하나의 큰 데이터베이스나, 캐시 저장소, 저장량 또는 모든 마이크로서비스가 쓸 수 있는 다른시스템을 공급하는게 더 좋을 수 있습니다. 중요한 점은 각각의 마이크로서비스 데이터 사이에는 파티션이 필요하다는 것 입니다 : 각각 마이크로서비스는 자신의 데이터를 독점적으로 가지고 있어야 합니다. 예를 들어, 스키마가 100개인 큰 데이터베이스 1개를 사용하는 것 보다 1개의 스키마를 갖는 100개의 데이터베이스를 사용하는것이 더 좋습니다. 즉, 데이터가 아니라 리소스를 자유롭게 공유하는 것 입니다.

커플링의 단점은 결합입니다. 당신의 마이크로서비스의 가용성은 누군가가 관리하는 데이터베이스의 가용성에 따라 달라지게 됩니다. 공유 데이터베이스를 관리하는 팀은 예약된 유지 관리를 위해 데이터베이스를 중지시켜야 할 수도 있습니다.

#### 주인의식(Ownership)
일반적인 enterprise 레벨의 상업 어플리케이션은 수백명의 사람이 어플리케이션을 위해 일을 합니다. 예를 들어, 100명의 백단 개발자들이 큰 규모의 단일 어플리케이션을 구축하는건 흔한일 입니다. 이 모델의 문제점은 맴버들은 자신들이 소유하지 못했다고 느끼는 것 입니다. 각각의 개발자들은 전체 코드의 1%정도만 다룹니다. 이러한 현상으로 개발자들은 책임감을 느끼기 어렵습니다.

경제적인 관념에서 보면, 주인의식의 결여는 'Tragedy of the Commons'로 잘 알려져 있습니다. 자신의 이익만을 위해 행동하는 개인(e.g., 소를 방목하는 농부)은 필연적으로 공동의 자원(e.g., 공동의 땅)에 대한 생각을 덜 하게 될 겁니다. 대규모의 단일 어플리케이션에서도 동일한 문제가 발생합니다. 수백의 참여자들이 자신의 이익만을 위해 행동한다면 단일 어플리케이션이 더 복잡해지고 기술적 부채가 가중됩니다. 모든 사람들은 누가 만들었는지 모르는 복잡한 기술적 부채를 다뤄야 할 것 입니다.

주인의식은 마이크로서비스 작동에 큰 부분을 차지합니다. 2명에서 15명으로 구성된 작은 팀이 마이크로서비스의 전체 라이프사이클을 구축하고 관리합니다. 팀은 자신들의 마이크로서비스를 소유 하고있습니다. 주인의식은 완전히 다른 사고방식을 가져옵니다. 담당자들은 마이크로서비스의 성공을 위해 장기적으로 책임이 있기 때문에 잘 관리합니다. 수백의 사람들이 포함된 큰 규모의 단일 어플리케이션에서는 말이 안되는 일 입니다. 한 팀에 3명의 개발자, 1명의 운영담당자 및 1명의 비즈니스 분석가가 있다고 가정합니다. 이 경우, 지정된 개발자는 33% 코드에 기여하게 됩니다. 이 팀의 모든 사람은 상당한 기여를 하고 있으며 그 기여를 쉽게 인정받을 수 있습니다. 만약 마이크로서비스가 100% 완벽하게 동작한다고 하면, 팀은 신용을 얻을 수 있습니다. 같은 맥락에서, 마이크로서비스가 완벽하지 못할 경우 책임을 전가하기 쉽습니다.

개인적인 차원에서, 큰 팀속에 숨을 수 없기 때문에 마이크로서비스는 사람의 능력을 최고로 이끌어냅니다. 어느 팀에서라도 개인의 성과는 표준 중 곡선의 형태를 뛰게 합니다. 최고의 성과를 내는 사람들은 마이크로서비스에 큰 영향력을 미칠 수 있기 때문에 마이크로서비스를 좋아합니다. 마이크로서비스는 더 많은 책임감을 갖게 해주기 때문에 높은 성과를 내는 사람들에게 매력적입니다.

마이크로서비스를 책임지는 팀은 2명 이상 15명 이하로 구성되어져야만 합니다. 가장 좋은 인원수는 7명에서 土2명입니다. 팀 규모에 영향을 미치는 몇가지 흥미로운 연구결과가 있습니다.

* 2명
  * 활용 할 기술이 부족합니다. 2사람은 "팀"으로 부르기 힘듭니다. 이것은 스스로의 과제만 해결 할 수 있는 관계에 가깝습니다.
* 3명
  * 한 사람은 종종 제외되거나 한 사람이 두명을 통제하기 때문에 불안정한 그룹을 이룹니다.
* 4명
  * 4명으로 이루어져 응집력이 있기 보단, 2명씩 나누어 지게 됩니다.
* 5명에서 9명
  * "팀"의 기분이 나게 됩니다. 충분히 활용 할 기술력이 있고, 소규모 팀의 불안정함을 피할 수 있고, 모두가 의견을 들을 수 있을 수 있습니다.
* 10명에서 15명
  * 팀이 너무 커집니다. 모두가 의견을 들을 수 없고, 작은 그룹으로 나누어 지게 됩니다.
    
각 팀은 개발, 운영, 데이터 저장 관리, 보안, 프로젝트 매니저, 요구사항 분석 등등 다양한 기술을 가지고 있어야 합니다. 종종 팀은 한명의 비즈니스 분석가, 한명 또는 두명의 운영인력 그리고 소수의 개발자고 구성됩니다. 종종 한 팀 내의 각각 다른 구성원의 일을 수행합니다. 예를 들어, 5명으로 구성 팀에서 단일 운영인력이 휴가를 간다고 하면 한명의 개발자가 운영업무를 대체 합니다.

팀 규모에서 중요한 원동력은 신뢰 입니다. 진짜 일을 하기 위해서는 신뢰가 필요합니다. 만약 팀에서 신뢰가 부족하게 된다면, 개인들은 자신들을 보호하면서 보상받으려고 합니다. 이러한 보호는 종종 과도한 서류작업(i.e., 변경 요청, 생산 준비 상태 검토, 아키텍처 검토)과 문서 형태를 취합니다. 비록 이런것이 문제가 발생 하였을 때 책임을 분산시킬 수 있을 수 있지만, 이러한 행동은 조직의 목표에 역효과를 발생 시킵니다. 규모가 작고, 신뢰할 수 있는 팀은 이러한 문제를 겪지 않습니다.

팀 규모를 보는 또 다른 방법은 의사 소통 경로입니다. 팀 구성원이 추가됨에 따라 커뮤니케이션 경로가 기하 급수적으로 증가하고, 진행 속도가 느려집니다. Fred Brooks가 1975년 쓴 'The Mythical Man Month'라는 책에서 팀 내 의사 소통의 경로수를 계산하는 공식을 발표 하였습니다. 한 팀에서, 의사소통의 경로 수는 [n*(n–1)]/2 (n은 팀사이즈)로 정의 됩니다. 아래 그림 2-5에서 볼수 있듯이 2명으로 구성된 팀은 1개의 의사소통 경로가 존재하지만 20명이 존재하는 팀의 의사소통 경로는 190개 입니다. 경로의 수가 작을 수록 더 빠른 개발이 이루어 지고 직원들의 만족도를 높일 수 있습니다.

![그림 2-5. 팀에서의 커뮤니케이션 경로](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-5.png)

그림 2-5. 팀에서의 커뮤니케이션 경로

#### 자율성(Autonomy) 
주인의식은 자율성 없이 존재 할 수 없습니다. 자율성은 마이크로서비스 중 많은 부분을 의미합니다.

각각의 팀은 프로그래밍 언어, 런타임, 저장소 그리고 고려해야할 사항들에 대한 비즈니스적 문제를 풀기위해서 가장 적합한 기술을 선택할 수 있습니다. 제품의 이미지의 치수를 조정하는 마이크로서비스를 위한 기술 스택은 쇼핑 카트 마이크로서비스의 기술 스택과 매우 다르게 보일 것 입니다. 각 팀은 각 부분에서 필요한 가장 최적합한 기술 스택을 선택 할 수 있습니다. 그리고 그 결정에 책임을 집니다. 각각의 마이크로서비스는 API를 통해서 노출됩니다. 그래서 세부 구현 사항을 그렇게 중요한 사항은 아닙니다. 말하자면, 기업들이 각 팀에게 옵션 메뉴중 선택을 하도록 요구하는것이 타당합니다. 예를 들어, 프로그래밍 언어는 Java, Scala, Node.js 등이 있습니다. 데이터저장소 옵션은 MongoDB, Cassandra 또는 MariaDB가 될 수 있습니다. 무엇이 되었든 각 팀은 가장 일하는데 적합한 상품 타입(Relational, Document, Key/Value, etc.)을 선택 할 수 있지만, 꼭 제품(MongoDB, Cassandra, MariaDB) 그 자체는 아닙니다. 팀은 API Protocol/format, 메세징, 로깅, 알림 등과 같이 구현의 세부 정보를 표준화 해야 합니다. 하지만 내부적으로 사용하는 기술은 각 팀에 달려 있습니다.

기술의 선택과 함께, 각 팀은 그 결정들이 마이크로서비스의 밖에서 보이지 않는 한 아키텍쳐나 구현에 대한 결정을 해야합니다. 각 마이크로서비스의 아키텍쳐를 승인하는 전사적 차원의 아키텍쳐 검토위원회가 있으면 안됩니다. 코드의 리뷰는 외부의 있는 누군가가 아니라 팀에 속한 개발자가 수행해야 합니다. 좋든지 나쁘던지, 구현에 대한 결정은 마이크로서비스를 소유하고 책임감을 가지고 있는 팀에 따라야 합니다. 만약 마이크로서비스가 기대에 부흥하지 못한다면, 새로운 팀을 구성해야 합니다. 각각의 마이크로서비스는 세부적인 비스니스를 수행하고 있기 때문에 작은 규모를 가지고 있어야 한다는걸 기억하여야 합니다.

각팀은 완벽히 고립된 상태에서 다른팀에 의존하지 않고 마이크로서비스를 구축하고 운영해야합니다.
한 팀은 다른팀에 사로잡혀 라이브러리를 구축하면 안됩니다.
하나의 마이크로서비스는 시작하거나 운영을 하면서 다른 마이크로서비스를 호출 할 필요가 없어야 합니다.
각 마이크로서비스는 독립적으로 구현되고 관리되게 구축된 나눠진 어플리케이션 입니다.

각 팀은 언제든 어떤 이유든 새로운 버전의 마이크로서비스를 배포 할 수 있어야 합니다.
만약 2.4버전의 마이크로서비스를 현재 사용하고 있다면, 그 팀은 2.5버전과 3.0 버전까지 배포 할 수 있어야 합니다.

#### 다양한 버전(Multiple version)
마이크로서비스의 또 다른 정의된 특성은 동일한 환경에 둘 이상의 마이크로서비스 버전을 동시에 배포할 수 있는 능력입니다.
예를 들어, 버전 2.2, 2.3, 2.4 그리고 3.0 으로 책정된 마이크로서비스는 동시에  제품에 존재 할 수 있습니다.
모든 버전은 트래픽을 처리할 수 있습니다. 클라이언트(e.g., 판매 관점에서 웹, 모바일 그리고 키오스크) 및 다른 마이크로서비스는 HTTP 요청을 할 때 특정버전의 마이크로서비스를 요청 할 수 있습니다.
이것은 대게 URL을 통해 이루어집니다.(e.g., /inventory/2/ or /inventory?version=2)
이것은 최소 기능 제품(MVPs)에 배포 할때 유용합니다.
v1을 배포하고 사용자들에게 사용하도록 합니다. 나중에 더 완벽한 제품인 v2를 배포합니다.
단일 배포를 할 때와 다르게 "Lock"을 걸지 않아도 됩니다.

반면에 단일 어플리케이션의 경우, 융통성이 없습니다. 대게, 한가지 버전의 단일 어플리케이션만 주어진 시간에만 존재합니다.
버전 2.2의 단일 어플리케이션이 완전히 중단 된 후 버전 2.3이 전개되며 트래픽이 다시 동작합니다.

여러 클라이언트를 지원하는 것은 마이크로서비스의 강력한 능력이고, 진정으로 omnichannel 상업을 가능하게 합니다.
클라이언트와 기타 마이크로서비스는 특정한 주요 API 버전으로 코드화 할 수 있습니다.
에코시스템 코드가 주요 버전1이라고 가정합니다. 마이크로서비스를 담당하는 팀은 버전 1.1, 1.2, 1.3을 구현하고 배포된 API에 영향이 없는 선에서 버그를 수정하고 새로운 기능을 구현 할 수 있습니다.
그림 2-6에서 보는것과 같이 버전1과 API의 호환성이 끊어지고 나중에, 팀은 버전 2를 배포 할 수 있습니다.

![그림 2-6. 같은 서비스의 여러 버전을 통해 클라이언트가 독립적으로 진화](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-6.png)

그림 2-6. 같은 서비스의 여러 버전을 통해 클라이언트가 독립적으로 진화

사용 가능한 새 버전이 있지만 사용할 필요가 없을 때 고객 및 기타 마이크로서비스에 알릴 수 있습니다. 버전 1과 2는 공존하게 됩니다.
1년 후 버전2가 배포 되었을때, 누구도 버전1을 사용하지 않는다면 버전 1은 완전하게 제거 됩니다.

단일 어플리케이션은 모든 클라이언트가 동일한 버전의 어플리케이션을 강제적으로 사용하게하는 문제를 겪고 있습니다.
호환성에 지장을 주는 API변경 사항이 있을 때마다 모든 클라이언트를 업데이트 해야 합니다.
한사람만의 고객이 웹사이트를 사용한다면 이건 괜찮은 방법입니다. 모바일과 웹이 되면서 이것은 더 어려워 집니다.
하지만 오늘날 전 세계에서, 자신만의 배포주기를 가진 다수의 클라이언트가 있을 것 입니다.
수십의 클라이언트가 동시에 새로운 버전을 배포하는 것은 불가능한 일 입니다.
각 클라이언트는 자신들의 버전을 코드화 해야 하고, 각 클라이언트가 자체 릴리스 주기를 거치면서 이후 버전으로 마이크레이션을 수행 해야 합니다.
이 접근 방식은 고객에 관계없이 각 마이크로서비스를 신속하게 혁신 할 수 있습니다.
이러한 copuling의 부족이 마이크로 서비스를 더욱 빠르게 만듭니다.

마이크로서비스가 여러 버전을 동시에 지원하는데 따른 주요 과제는 환경의 모든 버전이 동일 한 백업 데이터스토어, 캐시 저장소, 스토리지 볼륨 또는 기타 스토리지 스키마에 대해 읽기/쓰기를 수행해야 한다는것 입니다.
마이크로서비스의 데이터는 코드가 변경되더라도 일관되어야 합니다.
예를 들어, 버전 1.2의 상품 마이크로서비스는 백업 데이터베이스에 새로운 제품을 wirte할 수 있습니다.
후에, 버전 2.2의 동일한 마이크로서비스는 동일한 제품을 검색 할 수 있고, 그 반대도 가능합니다.
이것을 깰 수는 없습니다. 유사하게, 수신 메세지는 모든 버전의 마이크로서비스에서 처리 될 수 있습니다.

##### 진화 가능한 APIs
> 여러 버전의 동일한 API가 아닌 하나의 진화가능한 API를 제공 하는것은 가능합니다. 
> 진화하는 하나의 API가 앞 단락에서 언급한 문제들을 해결하지만, 변경가능한 level을 줄이는 것에는 비용이 수반됩니다.
> 예를 들어, 기존 구현된 것에 의존하는 다수의 클라이언트가 있을 수 있기 때문에, 가격책정 API는 다시 쓸 수 없습니다.
> API를 긴급하게 다시 작성할 필요가 없는 경우, 여러 버전의 동일한 API를 사용하는 것 보다 단일 API를 사용하는 것이 더 좋습니다.

둘 이상의 버전에 대한 지원은 개발 및 구축에 새로운 양상을 더 합니다. 그것이 마이크로서비스가 근본적으로 내부와 외부 복잡성 사이의 절충 안으로 보여지는 이유입니다.
그러나 클라이언트와 긴밀하게 연결되지 않아 혁신을 빨리 할수 있다는 장점은 비용을 능가합니다.

#### 연출(Choregraphy)



## 마이크로서비스의 이점(Advantages of Microservices)
마이크로서비스는 많은 이점을 제공합니다. 그 중 몇개를 구체적으로 짚어보겠습니다.

### 출시기간 단축

새로운 특징들의 출시기간 단축은 마이크로서비스의 가장 중요한 이점입니다. 초기에 시장에 진입하는 전체적인 시간은 마이크로서비스로 도입된 부가적인 선행 복잡성 때문에 더 길어질 수 있습니다. 하지만 도입되고 난 이후에는, 각 팀은 독립적으로 혁신하고 매우 빠르게 출시할 수 있습니다.(자료 2-13)

자료 2-13 각 팀은 독립적으로 혁신할 수 있습니다.

시장에 빠르게 진입할 수 있는 특징을 갖는 것은 사업에서 상당히 중요한 이점을 가질 수 있습니다. 만약 출시를 위한 생산이 분기별로 이뤄지고 올바르게 바로잡기 위해 4번의 반복이 필요하다면, 결국 바로 잡는데에 1년의 시간이 소요됩니다. 만약 출시가 매일 이뤄지고 바로잡기 위해 4번의 반복이 필요하다면, 단 4일이 소요됩니다.

빠른 반복뿐 아니라, 마이크로서비스는 실패를 더 빠르게 발생시킬 수 있습니다. 때때로, 특징들은 예상대로 작용하지 않습니다. 출시 취소되기까지 한 분기를 기다리는 것 보다 즉시 취소할 수 있는 것이 낫습니다.

마이크로서비스는 의존도를 제거하기 때문에 빠릅니다. 마이크로서비스로 다음과 같은 사항을 고려할 필요가 없습니다.

* 일원화된 구조 검토 위원회로부터의 구조적 승인
* 경영위원으로부터 출시 승인
* 수평적 의존성 - 예를들어, 공유된 DB수정을 위해 DBA를 기다릴 필요가 없고, 공급산출을 위해 영업활동이 필요가 없음
* 수직적으로 의존적인 다른팀과 출시 조정 - 예를들어, 재고 마이크로서비스는 상품 마이크로서비스 팀과 나란히 출시할 필요가 없을 것입니다.
* 이러한 기능을 수행하는 QA, 보안팀 등 각 팀의 승인

### 진정한 옴니채널 커머스
완전한 마이크로서비스 도입은 세분화된 여러 비즈니스 기능을 위해 개별 API를 갖는 것을 의미한다.     이러한 API들 위에 있는 사용자 인터페이스는 일회용이 될 것입니다. 차후에 Apple 혹은 Facebook은 전체적인 백엔드를 구성하지 않고 쉽게 만들 수 있는 새로운 타입의 어플리케이션을 도입할 것입니다.     새로운 사용자 인터페이스가 며칠내에 구축될 수 있습니다.

### 더 낫고 덜 복잡한 코드
마이크로서비스는 하나의 마이크로서비스가 한 비즈니스 기능을 수행하기 때문에 훨씬 나은 코드를 만드려고 노력합니다. 큰 단일 어플리케이션은 수천만 라인의 코드로 이뤄지는 반면 한 마이크로서비스는 수천의 라인으로 이뤄질 수 있습니다. 물론, 적은 코드는 훨씬 규모가 큰 코드보다 더 나을 것입니다.

코드도 소규모의 팀이 소유하면서 책임지는 구조이기 때문에 더 낫습니다.

## 마이크로서비스의 단점(Disadvantages of Microservices)

비록 마이크로 서비스가 확실히 장점을 가지고 있지만, 이와 마찬가지로 단점 또한 가지고 있습니다. 마이크로 서비스의 목표는 새로운 기능의 제공 속도를 높이는데 있습니다. 비용을 줄이는 것이 아닙니다. 새로운 기능을 신속하게 출시하는 것은 추 후 잠재적인 높은 마이크로서비스 개발비용을 상쇄하게 될 것입니다.

### 외부 복잡성의 어려움

마이크로서비스는 종종 외부 복잡성을 위해 내부를 희생시키는것으로 여겨집니다. 단일 어플리케이션은 내부가 복잡하지만 마이크로서비스의 내부는 간단합니다. 단일 어플리케이션의 외부 복잡성은 단순한 반면에 마이크로서비스의 외부 복잡성은 까다롭습니다. 이러한 차이를 통해 마이크로서비스팀은 새로운 기능을 매우 빠르게 구축하고 배치 할 수 있습니다. 하지만, 마이크로서비스간의 상호작용을 관리하는 비용을 수반합니다.

마이크로서비스의 외부 복잡성에 대한 예시를 소개하겠습니다.

* 데이터 동기화
  * 동기식 또는 비동기식 으로 마이크로서비스간 데이터 복사가 필요합니다.
* 보안
  * 누가/어떤것이 End Point를 호출할 것인가요? 검색할 수 있는 데이터는 무엇인가요? 어떤 동작만을 허용할 것인가요?
* 정보 찾기
  * 어떤 마이크로서비스가 사용가능한가요? 특정한 마이크로서비스에서 사용되는 메시지를 어떤것인가요?
* 버전 관리
  * 특정한 API나 특정 API 구현 버전을 어떻게 관리할 것인가요?
* 데이터 정확성
  * 어떤 마이크로 서비스가 주어진 데이터를 실제로 기록할 진짜 시스템인가요?

디버깅은 더 어렵습니다. 13.2버전 쇼핑카트 마이크로서비스와 19.1버전의 재고 관리 마이크로서비스가 서로 연관되어 있다면 어떻게 할까요? 언제든지 동시에 다양한 버전의 마이크로서비스들이 동일한 환경에 존재하는 것을 기억해야 합니다. 이러한 사항으로 모든 상관관계를 테스트 하는 것은 불가합니다. 그리고 마이크로서비스의 모든 상호작용에 대한 테스트를 중앙에서 관리하는 것은 마이크로서비스 사상에 반하는 것입니다.

### 조직 성숙도(Organizational Maturity)

조직은 탄탄한 구조와, 문화 그리고 기술적 역량을 가지고 있어야 합니다. 각각 하나씩 살펴보겠습니다.

우리가 이미 살펴본 것 처럼, 조직의 구조가 '소프트웨어 생성을 어떻게 해야하는가'를 정합니다. 계층을 중심으로 하는 중앙화 된 조직은 계층화 된 단일 어플리케이션 생성을 지향합니다. 단순한 변경일 지라도 계층 전체에 광범위한 조정이 필요하기 때문에 시간이 더 소요됩니다. 마이크로서비스를 만들기를 원하는 조직을 위한 더 나은 구조는 재품을 재구성 하는 것 입니다.
